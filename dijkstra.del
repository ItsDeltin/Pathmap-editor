import 'main.del';

Number closestNodeToPosition(Vector position): Nodes.Map((node, i) => i).SortedArray(i => Nodes[i].Node.Position.DistanceTo(position)).First;

globalvar Boolean pathfinderActive! = false;
globalvar Number dijkstraProgressReport = 0;

DijkstraResult Dijkstra(
    Number source,
    Number[] targets,
    Number[] attributes
) 'Subroutine: Dijkstra'
{
    if (pathfinderActive)
    {
        LogToInspector('Error: Attempted to pathfind while already active');
        return { Parents: null };
    }
    pathfinderActive = true;
    dijkstraProgressReport = 0;

    // WorldNode to actual node
    Number[] unvisited = Nodes.Map((node, i) => i);
    Number[] distances = unvisited.Map(node => 9999);
    Number[] parents = unvisited.Map(node => -1);

    distances[source] = 0;

    while (unvisited.Length && (targets == null || targets.IsTrueForAny(target => unvisited.Contains(target))))
    {
        Number current = unvisited.SortedArray(i => distances[i]).First;
        Number currentID = Nodes[current].Node.UniqueID;
        unvisited -= current;

        // Get the list of segments that contain the current node.
        // Only use the unvisited neighbors
        define neighbors = Nodes[current].Node.Neighbors
            .Map(n => NodeIndexFromID(n))
            .FilteredArray(node => unvisited.Contains(node));
        
        for (Number i = 0; neighbors.Length; 1)
        {
            Number neighborIndex = neighbors[i];
            Number neighborID = Nodes[neighborIndex].Node.UniqueID;
            Number[] neighborAttributes = Attributes.FilteredArray(
                attribute => attribute.Node1 == neighborID && attribute.Node2 == currentID
            ).Map(a => a.Value);

            Number newDistance = distances[current] + Nodes[current].Node.Position.DistanceTo(Nodes[neighborIndex].Node.Position);
            if (newDistance < distances[neighborIndex] &&
                (neighborAttributes.Length == 0 || neighborAttributes.IsTrueForAny(attribute => attributes.Contains(attribute)))
            )
            {
                distances[neighborIndex] = newDistance;
                parents[neighborIndex] = current;
            }
        }

        dijkstraProgressReport++;
        MinWait();
    }

    pathfinderActive = false;
    return { Parents: parents };
}

// Get the list of segments that contain the current node.
// Select the opposite node in the segment to get the list of neighbors.
Number[] getNodeNeighbors(Number nodeID): Segments
    .FilteredArray(segment => segment.Node1 == nodeID || segment.Node2 == nodeID)
    .Map(segment => NodeIndexFromID(segment.Node1 == nodeID ? segment.Node2 : segment.Node1));

struct DijkstraResult
{
    public Number[] Parents;
}

void MakeBake() playervar 'Subroutine: Make Bake'
{
    bakeResult = [];
    Number n = 0;

    define progressBar = CreateProgressBarHudText(
        AllPlayers(),
        (n / EvaluateOnce(Nodes.Length) + dijkstraProgressReport / EvaluateOnce(Nodes.Length) ^ 2) * 100,
        "Baking...",
        Location.Right,
        15,
        ProgressBarColor: Color.Orange,
        TextColor: Color.White
    );
    // Note: making dijkstra not wait on every single iteration would reduce the compile time by quite a lot.
    define endTime = TotalTimeElapsed() + Nodes.Length * (0.016 + Nodes.Length / 40 * 0.016 + Nodes.Length * 0.016);
    define timeRemaining: endTime - TotalTimeElapsed();

    define timeRemainingText = CreateHudText(
        AllPlayers(),
        Text: <'Time remaining: <0>:<2><1>', Max(timeRemaining / 60~Floor(), 0), Max(timeRemaining % 60~Floor(), 0), timeRemaining % 60 < 10 ? '0' : ''>,
        SortOrder: 16,
        Location: Location.Right);

    # For each node
    for (n = 0; Nodes.Length; 1) {
        # Node 'n's compressed data is stored in here.
        String[] compressed = [];
        # Will be appended to the end of compressed when it is large enough.
        String stub = '';
        # Pathfind current node.
        Number[] parents = Dijkstra(n, null, pathfinderAttributes).Parents;
        # Loop through each node relation.
        Number p;
        for (p = 0; parents.Length; 1) {
            # Compress value.
            stub = stub + bakeMatcher[parents[p] + 1]; // ! Add one so that we do not encode negative values. Exporter will need to adjust.
            # Append stub to compressed every 256 characters.
            if (p && !(p % 256)) {
                compressed += stub;
                stub = '';
            }

            // wait every 40 iterations
            if (!(p % 40))
                MinWait();
        }

        # If this condition is true, then stub still has contents that should be added to the
        # compressed data before we continue.
        if (p && p % 256) {
            compressed += stub;
            stub = '';
        }

        # Add compressed data.
        bakeResult[n] = compressed;
        # For good measure.
        compressed = null;

        MinWait();
    }

    DestroyProgressBarHudText(progressBar);
    DestroyHudText(timeRemainingText);
}

rule: 'Initialize Bake Matcher'
Event.OngoingPlayer
if (eventPlayer == host)
{
    bakeMatcher = BakemapStruct.GenerateMatchArray(500);
}

playervar String[][] bakeResult;
playervar String[] bakeMatcher;

rule: 'ostwmake'
Event.OngoingPlayer
if (host == eventPlayer)
if (button(Button.Ability2))
{
    PfHierarchy();
}

playervar Number[][] heirarchies;

Number hashVector(in Vector vec, in Number chunkSize): (vec / chunkSize).X.Floor() * 100 + (vec / chunkSize).Z.Floor();

void PfHierarchy() playervar 'Subroutine: Heirarchy'
{
    define tilesToNodes = MakeLowestLayer();
    Wait(1);
    define tiles = EnsureConnectivity(tilesToNodes);
    // Create node to node table

    // debug
    while (true) {
        for (define i = 0; tiles.ComponentsToNodes.Length; 1) {
            SmallMessage(AllPlayers(), <'highlighting component <0> in tile <1>', i, 
                tiles.TilesToComponents.keyWhereValue(nodes => nodes.Contains(i))>);
            for (define n = 0; tiles.ComponentsToNodes[i].Length; 1) {
                Nodes[tiles.ComponentsToNodes[i][n]].Selected = true;
                if (n == 0)
                    Teleport(AllPlayers(), Nodes[tiles.ComponentsToNodes[i][n]].Node.Position);
                MinWait();
            }

            WaitUntil(button(Button.SecondaryFire), 9999);
            WaitUntil(!button(Button.SecondaryFire), 9999);

            for (define n = 0; tiles.ComponentsToNodes[i].Length; 1) {
                Nodes[tiles.ComponentsToNodes[i][n]].Selected = false;
                MinWait();
            }
        }
        MinWait();
    }
}

void ComputeConnectivity() {

}

void AddHierarchy() {
}

void PolyTable(in Tile tiles) {
}

Tile EnsureConnectivity(ref Table<Number, Number[]> tilesToNodes) {
    SmallMessage(AllPlayers(), 'grouping connectivity');

    Number componentId = 0;
    // Tiles to components
    define newTiles = Table<Number, Number[]>.newTable(tilesToNodes.Keys);
    // Components to nodes
    Number[][] components = [];

    for (Number i = 0; tilesToNodes.length(); 1) {
        Number[] componentGraph: tilesToNodes.Values[i];

        // Copy the graph to a temporary variable.
        define unvisited = componentGraph;
        while (unvisited.Length) {
            // The buffer of nodes that will be visited.
            Number[] checkWeb = [unvisited.First];
            // The nodes that have been visited.
            Number[] web = [];
            // The accumulative midpoint of the visited nodes.
            Vector midpoint = Vector.Zero;
            while (checkWeb.Length) {
                // Add to midpoint
                midpoint += Nodes[checkWeb.First].Node.Position;
                // get connected nodes.
                // todo: it might be a good idea to ignore segments with attributes.
                checkWeb += getNodeNeighbors(Nodes[checkWeb.First].Node.UniqueID)
                    .FilteredArray(n => unvisited.Contains(n) && !checkWeb.Contains(n));
                // Add newly found nodes to the current web.
                web += checkWeb.First;
                // The current node has been visited.
                unvisited -= checkWeb.First;
                // Prepare the next node
                checkWeb.ModRemoveByIndex(0);
                MinWait();
            }
            midpoint /= web.Length;
            // Get the node closest to the component's midpoint.
            define middlestNode = web.SortedArray(n => Nodes[n].Node.Position.DistanceTo(midpoint)).First;

            components[componentId] = web;
            tableAppendValue(newTiles, tilesToNodes.Keys[i], componentId);
            componentId++;
            MinWait();
        }
        MinWait();
    }

    SmallMessage(AllPlayers(), 'connectivity grouped');

    return { TilesToComponents: newTiles, ComponentsToNodes: components };
}

Table<Number, Number[]> MakeLowestLayer()
{
    define tiles = Table<Number, Number[]>.newTable();

    SmallMessage(AllPlayers(), 'grouping');

    // Group nodes.
    for (Number i = 0; Nodes.Length; 1)
    {
        define node: Nodes[i];

        // Get the group this node will be going in.
        define hash = hashVector(node.Node.Position, 30);
        // Add the node index to the group.
        tableAppendValue(tiles, hash, i);
        MinWait();
    }

    SmallMessage(AllPlayers(), 'group completed');

    return tiles;
}

struct Tile
{
    public Number[][] ComponentsToNodes;
    public Table<Number, Number[]> TilesToComponents;
}