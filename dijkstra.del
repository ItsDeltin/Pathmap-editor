import 'main.del';

Number closestNodeToPosition(Vector position): Nodes.Map((node, i) => i).SortedArray(i => Nodes[i].Node.Position.DistanceTo(position)).First;

globalvar Boolean pathfinderActive! = false;
globalvar Number dijkstraProgressReport = 0;

DijkstraResult Dijkstra(
    Number source,
    Number[] targets,
    Number[] attributes
) 'Subroutine: Dijkstra'
{
    if (pathfinderActive)
    {
        LogToInspector('Error: Attempted to pathfind while already active');
        return { Parents: null };
    }
    pathfinderActive = true;
    dijkstraProgressReport = 0;

    // WorldNode to actual node
    Number[] unvisited = Nodes.Map((node, i) => i);
    Number[] distances = unvisited.Map(node => 9999);
    Number[] parents = unvisited.Map(node => -1);

    distances[source] = 0;

    while (unvisited.Length && (targets == null || targets.IsTrueForAny(target => unvisited.Contains(target))))
    {
        Number current = unvisited.SortedArray(i => distances[i]).First;
        Number currentID = Nodes[current].Node.UniqueID;
        unvisited -= current;

        // Get the list of segments that contain the current node.
        // Only use the unvisited neighbors
        define neighbors = Nodes[current].Node.Neighbors
            .Map(n => NodeIndexFromID(n))
            .FilteredArray(node => unvisited.Contains(node));
        
        for (Number i = 0; neighbors.Length; 1)
        {
            Number neighborIndex = neighbors[i];
            Number neighborID = Nodes[neighborIndex].Node.UniqueID;
            Number[] neighborAttributes = Attributes.FilteredArray(
                attribute => attribute.Node1 == neighborID && attribute.Node2 == currentID
            ).Map(a => a.Value);

            Number newDistance = distances[current] + Nodes[current].Node.Position.DistanceTo(Nodes[neighborIndex].Node.Position);
            if (newDistance < distances[neighborIndex] &&
                (neighborAttributes.Length == 0 || neighborAttributes.IsTrueForAny(attribute => attributes.Contains(attribute)))
            )
            {
                distances[neighborIndex] = newDistance;
                parents[neighborIndex] = current;
            }
        }

        dijkstraProgressReport++;
        MinWait();
    }

    pathfinderActive = false;
    return { Parents: parents };
}

struct DijkstraResult
{
    public Number[] Parents;
}

void MakeBake() playervar 'Subroutine: Make Bake'
{
    bakeResult = [];
    Number n = 0;

    define progressBar = CreateProgressBarHudText(
        AllPlayers(),
        (n / EvaluateOnce(Nodes.Length) + dijkstraProgressReport / EvaluateOnce(Nodes.Length) ^ 2) * 100,
        "Baking...",
        Location.Right,
        15,
        ProgressBarColor: Color.Orange,
        TextColor: Color.White
    );
    // Note: making dijkstra not wait on every single iteration would reduce the compile time by quite a lot.
    define endTime = TotalTimeElapsed() + Nodes.Length * (0.016 + Nodes.Length / 40 * 0.016 + Nodes.Length * 0.016);
    define timeRemaining: endTime - TotalTimeElapsed();

    define timeRemainingText = CreateHudText(
        AllPlayers(),
        Text: <'Time remaining: <0>:<2><1>', Max(timeRemaining / 60~Floor(), 0), Max(timeRemaining % 60~Floor(), 0), timeRemaining % 60 < 10 ? '0' : ''>,
        SortOrder: 16,
        Location: Location.Right);

    # For each node
    for (n = 0; Nodes.Length; 1) {
        # Node 'n's compressed data is stored in here.
        String[] compressed = [];
        # Will be appended to the end of compressed when it is large enough.
        String stub = '';
        # Pathfind current node.
        Number[] parents = Dijkstra(n, null, pathfinderAttributes).Parents;
        # Loop through each node relation.
        Number p;
        for (p = 0; parents.Length; 1) {
            # Compress value.
            stub = stub + bakeMatcher[parents[p] + 1]; // ! Add one so that we do not encode negative values. Exporter will need to adjust.
            # Append stub to compressed every 256 characters.
            if (p && !(p % 256)) {
                compressed += stub;
                stub = '';
            }

            // wait every 40 iterations
            if (!(p % 40))
                MinWait();
        }

        # If this condition is true, then stub still has contents that should be added to the
        # compressed data before we continue.
        if (p && p % 256) {
            compressed += stub;
            stub = '';
        }

        # Add compressed data.
        bakeResult[n] = compressed;
        # For good measure.
        compressed = null;

        MinWait();
    }

    DestroyProgressBarHudText(progressBar);
    DestroyHudText(timeRemainingText);
}

rule: 'Initialize Bake Matcher'
Event.OngoingPlayer
if (eventPlayer == host)
{
    // bakeMatcher = BakemapStruct.GenerateMatchArray(500);
}

playervar String[][] bakeResult;
playervar String[] bakeMatcher;

rule: 'ostwmake'
Event.OngoingPlayer
if (host == eventPlayer)
if (button(Button.Ability2))
{
    PfHierarchy();
}

playervar Number[][] heirarchies;

Number hashVector(in Vector vec, in Number chunkSize): (vec / chunkSize).X.Floor() * 100 + (vec / chunkSize).Z.Floor();
Number[] getNeighborhood(in Number hashedTile): [
    hashedTile - 101, hashedTile - 100, hashedTile - 99,
    hashedTile - 1, hashedTile, hashedTile + 1,
    hashedTile + 99, hashedTile + 100, hashedTile + 101
];

void PfHierarchy() playervar 'Subroutine: Heirarchy'
{
    // Split nodes into tiles. 
    SmallMessage(AllPlayers(), 'Tiles to nodes');
    define tilesToNodes = MakeLowestLayer();

    // First component split: ensure that 
    SmallMessage(AllPlayers(), 'Node connectivity');
    define tiles = EnsureConnectivity(tilesToNodes);

    // Create node to node table
    SmallMessage(AllPlayers(), 'Node-to-node table');
    NodeToNodeTable(tiles);
    SmallMessage(AllPlayers(), 'Node-to-node completed');

    // debug
    while (true) {
        for (define i = 0; tiles.ComponentsToNodes.Length; 1) {
            SmallMessage(AllPlayers(), <'highlighting component <0> in tile <1>', i, 
                tiles.TilesToComponents.keyWhereValue(nodes => nodes.Contains(i))>);
            for (define n = 0; tiles.ComponentsToNodes[i].Length; 1) {
                Nodes[tiles.ComponentsToNodes[i][n]].Selected = true;
                if (n == 0)
                    Teleport(AllPlayers(), Nodes[tiles.ComponentsToNodes[i][n]].Node.Position);
                MinWait();
            }

            WaitUntil(button(Button.SecondaryFire), 9999);
            WaitUntil(!button(Button.SecondaryFire), 9999);

            for (define n = 0; tiles.ComponentsToNodes[i].Length; 1) {
                Nodes[tiles.ComponentsToNodes[i][n]].Selected = false;
                MinWait();
            }
        }
        MinWait();
    }
}

void ComputeConnectivity() {

}

void AddHierarchy() {
}

void NodeToNodeTable(in Tile tiles) {
    // Each node's tables.
    Table<Number, Number>[] nodeTables = [];

    // For each tile
    for (Number t! = 0; tiles.TilesToComponents.length(); 1) {
        // Get neighboring tiles.
        Number[] tileNeighborhood = getNeighborhood(tiles.TilesToComponents.Keys[t]);
        // Get each node in each neighboring tile.
        Number[] nodeNeighborhood = tiles.GetNodesInNeighborhood(tileNeighborhood);
        // Create node-to-node table
        tiles.ForeachNodeInTile(t, node => {
            # append to node table
            nodeTables += [GetPathsToNode(node, nodeNeighborhood)];

            MinWait();
        });
    }
}

Table<Number, Number> GetPathsToNode(in Number nodeIndex, Number[] neighborhood!) {
    # 'neighborhood' will serve as the unvisited array.
    # Each node in the neighborhood will have a value pointing towards nodeIndex.
    // NOTICE: This won't work if the shortest path between two nodes in the tile
    // needs to exit the neighborhood. This will probably need to be extended to every
    // node in the map.
    define pathTable = Table<Number, HeirarchyDijkstraNode>.newTable(
        keys: neighborhood,
        values: neighborhood.Map(n => {
            Distance: 9999,
            NextNode: -1
        })
    );
    // ostw needs a better way of doing this D:
    // const pointer time ;(
    pathTable.Values[pathTable.indexOfKey(nodeIndex)].Distance = 0;
    
    while (neighborhood.Length)
    {
        # Get the node with the least distance.
        # This will be index in the Nodes array, or the ID in the path table.
        Number current! = neighborhood.SortedArray(n => pathTable.get(n).Distance).First;
        neighborhood -= current;
        
        # Get the node's neighbors that are also inside the tile neighborhood.
        Number[] neighbors! = Nodes[current].Node.Neighbors
            .Map(n => NodeIndexFromID(n))
            .FilteredArray(n => neighborhood.Contains(n));
        
        foreach (Number neighbor! in neighbors)
        {
            Number newDistance! = pathTable.get(current).Distance + Nodes[current].Node.Position.DistanceTo(Nodes[neighbor].Node.Position);
            
            if (newDistance < pathTable.get(neighbor).Distance) {
                # Update distance and parents.
                pathTable.Values[pathTable.indexOfKey(neighbor)].Distance = newDistance;
                pathTable.Values[pathTable.indexOfKey(neighbor)].NextNode = current;
            }
        }

        MinWait();
    }

    return pathTable.mapValue(v => v.NextNode);
}

Tile EnsureConnectivity(ref Table<Number, Number[]> tilesToNodes) {
    SmallMessage(AllPlayers(), 'grouping connectivity');

    Number componentId! = 0;
    // Tiles to components
    define newTiles = Table<Number, Number[]>.newTable(tilesToNodes.Keys);
    // Components to nodes
    Number[][] components = [];

    for (Number i = 0; tilesToNodes.length(); 1) {
        Number[] componentGraph: tilesToNodes.Values[i];

        // Copy the graph to a temporary variable.
        define unvisited! = componentGraph;
        while (unvisited.Length) {
            // The buffer of nodes that will be visited.
            Number[] checkWeb = [unvisited.First];
            // The nodes that have been visited.
            Number[] web = [];
            while (checkWeb.Length) {
                // get connected nodes.
                // todo: it might be a good idea to ignore segments with attributes.
                checkWeb += Nodes[checkWeb.First].Node.Neighbors
                    .Map(n => NodeIndexFromID(n))
                    .FilteredArray(n => unvisited.Contains(n) && !checkWeb.Contains(n));
                // Add newly found nodes to the current web.
                web += checkWeb.First;
                // The current node has been visited.
                unvisited -= checkWeb.First;
                // Prepare the next node
                checkWeb.ModRemoveByIndex(0);
                MinWait();
            }
            components[componentId] = web;
            tableAppendValue(newTiles, tilesToNodes.Keys[i], componentId);
            componentId++;
            MinWait();
        }
        MinWait();
    }

    SmallMessage(AllPlayers(), 'connectivity grouped');

    return { TilesToComponents: newTiles, ComponentsToNodes: components };
}

Table<Number, Number[]> MakeLowestLayer()
{
    define tiles = Table<Number, Number[]>.newTable();

    SmallMessage(AllPlayers(), 'grouping');

    // Group nodes.
    for (Number i! = 0; Nodes.Length; 1)
    {
        define node: Nodes[i];

        // Get the group this node will be going in.
        define hash = hashVector(node.Node.Position, 30);
        // Add the node index to the group.
        tableAppendValue(tiles, hash, i);
        MinWait();
    }

    SmallMessage(AllPlayers(), 'group completed');

    return tiles;
}

struct Tile
{
    # [Component ID] to [...Node Indexes...]
    public Number[][] ComponentsToNodes;
    # Tile ID to [...Component IDs...]
    public Table<Number, Number[]> TilesToComponents;

    Number[] GetNodesInNeighborhood(in Number[] tiles)
    {
        Number[] result = [];
        foreach (Number tile! in tiles)
            TilesToComponents.ifKey(tile, (components, i) => {
                foreach (Number component! in components) {
                    result += ComponentsToNodes[component];
                }
            });
        return result;
    }

    void ForeachNodeInTile(in Number tileIndex, const Number => void iter)
    {
        Number[] components: TilesToComponents.Values[tileIndex];
        foreach (Number component! in components)
            foreach (Number node! in ComponentsToNodes[component])
                iter(ComponentsToNodes[component][node]);
    }
}

struct HeirarchyDijkstraNode
{
    public Number Distance;
    public Number NextNode;
}