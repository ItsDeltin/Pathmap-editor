import 'main.del';
import 'map languages.del';

String sep: '\n⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯';

enum OutputLanguage
{
    Workshop,
    OSTW,
    OverPy
}

# `0` = Workshop, `1` = OSTW, `2` = overpy
globalvar persist Number outputLanguage;

# Determines which components get built.
# `[0]`: The map itself. (default: true)
# `[1]`: The custom rules. (default: true)
# `[2]`: The core pathfinding code. (default: false)
globalvar Boolean[] buildToggles = [true, true, false];

globalvar Number selectWorkshopButton!;
globalvar Number selectOstwButton!;
globalvar Number selectOverpyButton!;
globalvar Number exportButton!;

void ExportMenu() 'EXPORT: create export menu'
{
    setMainLabel("main / export");

    createHelpButton(posX: -1.25, posY: .8,
        'Export settings', [
            MessageLine.Text('These settings decide which pathfinding components will be exported.\n'
                + 'The generated code exported should be copied into your gamemode.\n\n', Color.White),
            MessageLine.Separator('Export Map', Color.Green),
            MessageLine.Text(<'If enabled, the nav mesh you created for <0> will be generated.\n\n', CurrentMap()>, Color.White),
            MessageLine.Separator('Export Custom Rules', Color.Green),
            MessageLine.Text('If enabled, the custom rules in the rule menu will be compiled into the specified workshop language.\n\n', Color.White),
            MessageLine.Separator('Core pathfinding code', Color.Yellow),
            MessageLine.Text('If enabled, the core pathfinding algorithm will be generated.\n' +
            'This only needs to be added to your project once.', Color.White)
        ]);
    buttonCollectionMain += createButton(
        label: "┏━ Export Settings ━┓",
        posX: -1.25,
        posY: .6,
        defaultColor: Color.White,
        interactable: false
    );
    CreateToggle(0, 'Export Map', posX: -1.25, posY: .3);
    CreateToggle(1, 'Export Custom Rules', posX: -1.25, posY: .0);
    CreateToggle(2, 'Core Pathfinding Code', posX: -1.25, posY: -.3);
    
    createHelpButton(posX: 1.5, posY: .8,
        'Pathmaps can be compiled into several workshop languages.   ', [
            MessageLine.Separator('Workshop Code', Color.Green),
            MessageLine.Text('Vanilla workshop syntax.\nThis can be pasted directly into the game.\n\n', Color.White),
            MessageLine.Separator('Ostw', Color.SkyBlue),
            MessageLine.Text(
'An abstraction over the workshop allowing programming features such as collections in the form of
structs or classes, object '+ 'oriented programming, and lambdas.', Color.White),
            MessageLine.Text('https://github.com/ItsDeltin/Overwatch-Script-To-Workshop\n\n', Color.Blue),
            MessageLine.Separator('Overpy', Color.Yellow),
            MessageLine.Text(
'Code your gamemodes with modern development practices and break the limitations of the
workshop UI with features such as '+'multiple files, macros, switches, enums, optimizations,
string splitting, better syntax, etc.', Color.White),
            MessageLine.Text('https://github.com/Zezombye/overpy', Color.Blue)
        ]);
    buttonCollectionMain += createButton(
        label: "┏━ Language ━┓",
        posX: 1.5,
        posY: .6,
        defaultColor: Color.White,
        interactable: false
    );
    selectWorkshopButton = createButton(
        label: "",
        posX: 1.5,
        posY: .3,
        clickWidth: 1.2,
        defaultColor: Color.Green,
        onClick: left => {
            outputLanguage = 0;
            SetLanguageSelectLabels();
        },
    );
    selectOstwButton = createButton(
        label: "",
        posX: 1.5,
        posY: 0.,
        clickWidth: 1.2,
        defaultColor: Color.SkyBlue,
        onClick: left => {
            outputLanguage = 1;
            SetLanguageSelectLabels();
        },
    );
    selectOverpyButton = createButton(
        label: "",
        posX: 1.5,
        posY: -.3,
        clickWidth: 1.2,
        defaultColor: Color.Yellow,
        onClick: left => {
            outputLanguage = 2;
            SetLanguageSelectLabels();
        },
    );

    createHelpButton(posX: 0, posY: -0.7,
        'Code generation', [
            MessageLine.Text('This button will generate code that you will need to copy into your gamemode.\n' +
                'The code can be copied from the inspector by clicking the "Copy to clipboard all log" button.')
        ]);
    exportButton = createButton(
        label: '',
        posY: -0.9,
        clickWidth: 3,
        defaultColor: CustomColor(218, 253, 253, 255),
        onClick: left => {
            # Do nothing if nothing is going to be exported.
            if (!buildToggles[0] && !buildToggles[1] && !buildToggles[2]) {
                showMessage('Error', [MessageLine.Text('\n\nAll exporting options disabled, nothing to export.', Color.Rose)]);
            } else {
                Export();
            }
        }
    );

    buttonCollectionMain += [selectWorkshopButton, selectOstwButton, selectOverpyButton, exportButton];
    SetLanguageSelectLabels();
}

void SetLanguageSelectLabels() 'Subroutine: Set Language Select Labels'
{
    SetLabel(selectWorkshopButton, outputLanguage == 0 ? '【Workshop】' : 'Workshop');
    SetLabel(selectOstwButton, outputLanguage == 1 ? '【Ostw】' : 'Ostw');
    SetLabel(selectOverpyButton, outputLanguage == 2 ? '【Overpy】' : 'Overpy');
    SetLabel(exportButton, <'☆Generate code for <0>☆', ['the workshop', 'ostw', 'overpy'][outputLanguage]>);
}

void CreateToggle(in Number index, in String label, in Number posX, in Number posY)
{
    Number bid: NextButtonId();
    buttonCollectionMain += createButton(
        label: ExportBuildLabel(label, index),
        defaultColor: ExportBuildColor(index),
        posX: posX,
        posY: posY,
        clickWidth: 1.2,
        onClick: left => {
            buildToggles[index] = !buildToggles[index];
            SetLabel(bid, ExportBuildLabel(label, index));
            SetColor(bid, ExportBuildColor(index));
        },
    );
}

String ExportBuildLabel(String label, Number index): <'<0>: <1>', label, buildToggles[index] ? 'on' : 'off'>;
Color ExportBuildColor(Number index): buildToggles[index] ? Color.LimeGreen : CustomColor(182, 57, 57, 255);

rule: 'EXPORT: open export menu'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.Export)
{
    SetMenuState(MenuState.Export);
}

void Export() 'Subroutine: Generate map code.'
{
    # Enable inspector so we can log the exported code to it.
    EnableInspector();

    # First export the map.
    if (buildToggles[0]) {
        # Export map to workshop.
        if (outputLanguage == 0)
            ExportMapToWorkshop();
        # Export map to ostw.
        else if (outputLanguage == 1)
            ExportMapToOstw();
        # Export map to overpy.
        else if (outputLanguage == 2)
            ExportMapToOverpy();
    }
    # Secondly export the rules.
    if (buildToggles[1]) {
        ExportRules();
    }
    # Finally, export the core pathfinding code.
    if (buildToggles[2]) {
        ExportCore();
    }

    # Disable inspector.
    DisableInspector();

    # Show code generation completed message.
    showMessage('Pathfinding code generated!', [
        MessageLine.Separator('Your code has been generated, and you are almost ready to start pathfinding players!\n\n', Color.LimeGreen),
        MessageLine.Text(
            'Open the inspector and click the "Copy To Workshop All Log" button to copy the generated code to your clipboard.\n' +
            <'Paste the contents into a text editor<0>\n\n', outputLanguage == 0 ?
            '. Remove the first timestamp and then you can paste the workshop\ncode directly into your game.' : ', then follow the instructions in the text to use the pathfinder.'>),
        MessageLine.Separator(''),
        MessageLine.Text('It is recommended to restart the game instance before doing another export\n' +
            'because the copy will include *all* exports. Remember to save your map beforehand\nby copying the action set code!')
    ]);
}

void ExportCore() 'Subroutine: Export: Core'
{
    # Export core code to workshop.
    if (outputLanguage == 0)
        PrintStub('pathfinder/pathfind.ow', []);
    # Export core code to ostw.
    else if (outputLanguage == 1)
        PrintStub('pathfinder/pathfind.ostw', []);
    # Export core code to overpy.
    else if (outputLanguage == 2)
    {
    }
}

void ExportRules() playervar 'EXPORT: Export'
{
    // OngoingPlayer is not vital, it's just so we can use player variables here
    OutputLanguage lang: <OutputLanguage>outputLanguage;
    Boolean is_ow: lang == OutputLanguage.Workshop;
    Boolean is_ostw: lang == OutputLanguage.OSTW;
    Boolean is_overpy: lang == OutputLanguage.OverPy;

    for(define i = 0; Rules.Length; 1) {
        # Rule syntax
        ExportStatement(lang,
            '*/ rule(\"Custom Pathfinding Rule #{0}\") { /*'.Format([i + 1]),
            '*/ rule: \"Custom Pathfinding Rule #{0}\" /*'.Format([i + 1]),
            '*/\nrule \"Custom Pathfinding Rule #{0}\": @Event eachPlayer /*'.Format([i + 1])
        );

        Number numberOfEnabledHeroes! = Rules[i].EnabledHeroes.FilteredArray(x => x).Length;
        Number firstEnabledHero! = Rules[i].EnabledHeroes.IndexOf(true);

        # Add event (ow)
        if (is_ow) {
            LogToInspector(<'*/ event { Ongoing - Each Player; All; <0>; } /*',
                numberOfEnabledHeroes != 1 ? 'All' : AllHeroes()[firstEnabledHero]>);
        }
        # Add event (ostw)
        else if (is_ostw) {
            LogToInspector('*/ Event.OngoingPlayer /*');
            if (numberOfEnabledHeroes == 1) {
                LogToInspector(<'*/ Player.<0> /*', <'<0>',
                    AllHeroes()[firstEnabledHero]>
                    .Replace(' ', '') // wrecking ball/junker queen
                    .Replace(':', '') // soldier
                    .Replace('ú', '') // lucio
                    .Replace('.', '') // dva
                    .Replace('ö', '')>); // torb
            }
        }
        # Add event (overpy)
        else if (is_overpy && numberOfEnabledHeroes == 1) {
            LogToInspector(<'*/\n    @hero <0> /*',
                // todo: this needs to be in the same order as the heroes in AllHeroes().
                ['ana', 'ashe', 'baptiste', 'bastion', 'brigitte', 'doomfist', 'dva', 'echo', 'genji', 'hammond', 'hanzo',
                'junkerQueen', 'junkrat', 'kiriko', 'lucio', 'mccree', 'mei', 'mercy', 'moira', 'orisa', 'pharah', 'reaper',
                'reinhardt', 'roadhog', 'sigma', 'sojourn', 'soldier', 'sombra', 'torbjorn', 'tracer', 'widowmaker', 'winston',
                'zarya', 'zenyatta', 'ramattra'][firstEnabledHero]>);
        } 

        # Workshop code
        if (lang == OutputLanguage.Workshop) {
            LogToInspector('*/ conditions { /*');
            LogToInspector('*/     Array Contains(Event Player.pfAttributes, {0}) == True; /*'.Format([Rules[i].ExecutesOnAttribute]));
            LogToInspector('*/ } actions { /*');
        }
        # OSTW code
        else if (lang == OutputLanguage.OSTW) {
            LogToInspector('*/ if (pfAttributes.Contains({0})) /*'.Format([Rules[i].ExecutesOnAttribute]));
            LogToInspector('*/ { /*');
        }
        # Overpy code
        else if (lang == OutputLanguage.OverPy) {
            // TODO
            LogToInspector('*/\n    @Condition pfAttributes.contains({0}) /*'.Format([Rules[i].ExecutesOnAttribute]));
        }            
        
        # Loop through each action in the rule.
        for(define a = 0; Rules[i].Actions.Length; 1) {
            # Extract the action ID.
            define export = Rules[i].Actions[a].Export;
            define actionID: export.X;

            # Wait
            if (actionID == 0) {
                ExportAction(lang,
                    <'Wait(<0>, Ignore Condition);', export.Y>,
                    <'Wait(<0>);', export.Y>,
                    <'wait(<0>)', export.Y>);
            }
            # Jump
            else if (actionID == 1) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Jump));',
                    'PressButton(EventPlayer(), Button.Jump);',
                    'eventPlayer.forceButtonPress(Button.JUMP)');
            }
            # Start holding jump
            else if (actionID == 2) {
                ExportAction(lang,
                    'Start Holding Button(Event Player, Button(Jump));',
                    'StartHoldingButton(EventPlayer(), Button.Jump);',
                    'eventPlayer.startForcingButton(Button.JUMP)');
            }
            # Stop holding jump
            else if (actionID == 3) {
                ExportAction(lang,
                    'Stop Holding Button(Event Player, Button(Jump));',
                    'StopHoldingButton(EventPlayer(), Button.Jump);',
                    'eventPlayer.stopForcingButton(Button.JUMP)');
            }
            # Ability 1
            else if (actionID == 4) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Ability 1));',
                    'PressButton(EventPlayer(), Button.Ability1);',
                    'eventPlayer.forceButtonPress(Button.ABILITY_1)');
            }
            # Ability 2
            else if (actionID == 5) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Ability 2));',
                    'PressButton(EventPlayer(), Button.Ability2);',
                    'eventPlayer.forceButtonPress(Button.ABILITY_2)');
            }
            # Melee
            else if (actionID == 6) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Melee));',
                    'PressButton(EventPlayer(), Button.Melee);',
                    'eventPlayer.forceButtonPress(Button.MELEE)');
            }
            # Primary fire
            else if (actionID == 7) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Primary Fire));',
                    'PressButton(EventPlayer(), Button.PrimaryFire);',
                    'eventPlayer.forceButtonPress(Button.PRIMARY_FIRE)');
            }
            # Secondary fire
            else if (actionID == 8) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Secondary Fire));',
                    'PressButton(EventPlayer(), Button.SecondaryFire);',
                    'eventPlayer.forceButtonPress(Button.SECONDARY_FIRE)');
            }
            # Stop walking
            else if (actionID == 9) {
                ExportAction(lang,
                    'Stop Throttle In Direction(Event Player);',
                    'StopThrottleInDirection();',
                    'eventPlayer.stopThrottleInDirection()');
            }
            # Walk to destination
            else if (actionID == 10) {
                ExportAction(lang, "uhh;", "uhh();", "uhh()");
            }
            # Look at floor
            else if (actionID == 11) {
                ExportAction(lang,
                    "Start Facing(Event Player, Direction From Angles(Horizontal Facing Angle Of(Event Player), 89), 1000, To World, None);",
                    "StartFacing(EventPlayer(), DirectionFromAngles(HorizontalFacingAngleOf(), 89), 1000, Relative.ToWorld, FacingRev.None);",
                    "eventPlayer.startFacing(angleToDirection(eventPlayer.getHorizontalFacingAngle(), 89), 1000, Relativity.TO_WORLD, FacingReeval.NONE)");
            }
            # Look at destination
            else if (actionID == 12) {
                ExportAction(lang, "uhh;", "uhh();", "uhh()");
            }

            MinWait();
        }

        # End rule & actions for the c-like languages 
        if (lang == OutputLanguage.Workshop)
            LogToInspector('*/ } } /*');
        else if (lang == OutputLanguage.OSTW)
            LogToInspector('*/ } /*');
        
        MinWait();
    }
}

void ExportCompressedDataToWorkshop() playervar "EXPORT: compressed data to workshop" 
{
    // This function assumes MakeBake() was already executed.

    EnableInspector();
    // String variableCompatibleMapName = '{0}'.Format([CurrentMap()])
    //     .Replace(' ', '')
    //     .Replace('(', '')
    //     .Replace(')', '')
    //     .Replace(':', '');

    # Add rule and event
    LogToInspector('*/ rule(\"GENERATED: {0} compressed map data\") { event { Ongoing - Global; } /*'.Format([CurrentMap()]));
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Make sure this is the correct map
    LogToInspector(mapCondition);
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Set compressed data
    LogToInspector('*/     global.pathfinder_compressed = Array(Array(Custom String( /*');

    # For each node
    for (define a = 0; bakeResult.Length; 1) {
        # Add each stub
        for (define b = 0; bakeResult[a].Length; 1) {
            # String value
            LogToInspector('*/\"{0}\"/*'.Format([bakeResult[a][b]]));
            # End string
            LogToInspector('*/         ){0} /*'.Format([
                b < bakeResult[a].Length - 1 ? ', Custom String(' :
                a < bakeResult.Length - 1 ? '), Array(Custom String(' : '));'
            ]));
            MinWait();
        }
        MinWait();
    }
    # End action & rule block
    LogToInspector('*/ } } /*');

    ExportNodes();
    ExportAttributes();
    ExportSegments();
    
    DisableInspector();
}

void ExportMapToWorkshop()
{
    ExportNodes();
    ExportSegments();
    ExportAttributes();
}

void ExportNodes()
{
    # Nodes rule
    LogToInspector('*/ rule(\"GENERATED: {0} nodes\") { event { Ongoing - Global; } /*'.Format([CurrentMap()]));
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Make sure this is the correct map
    LogToInspector(mapCondition);
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Set pathfinder_nodes
    LogToInspector('*/     global.loadedMap_nodes = Array( /*');
    # For each node
    for (Number a! = 0; Nodes.Length; 10) {
        String stub = '';
        for (Number b! = a; Min(a + 10, Nodes.Length); 1) {
            define vector = Nodes[b].Node.Position;
            stub = stub + <'Vector<0><1>',
                vector,
                b < Nodes.Length - 1 ? ', ' : ');'>;
        }
        LogToInspector('*/{0}/*'.Format([stub]));
        MinWait();
    }
    # End action & rule block
    LogToInspector('*/ } } /*');
}

void ExportAttributes()
{
    # Attributes rule
    LogToInspector('*/ rule(\"GENERATED: {0} attributes\") { event { Ongoing - Global; } /*'.Format([CurrentMap()]));
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Make sure this is the correct map
    LogToInspector(mapCondition);
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Set pathfinder_attributes
    LogToInspector('*/     global.loadedMap_attributes = Array( /*');
    # For each attribute
    ExportArray(Attributes, 10, (attribute, isLast) => <'Vector(<0>, <1>, <2>)<3>',
        NodeIndexFromID(attribute.Node1), NodeIndexFromID(attribute.Node2), attribute.Value,
        isLast ? '); ' : ', '>);
    # End action & rule block
    LogToInspector('*/ } } /*');
}

void ExportSegments()
{
    ExportMapBlock('segments', () => {
        # Set pathfinder_segments
        LogToInspector('*/     global.loadedMap_paths = Array( /*');
        # For each attribute
        ExportArray(Segments, 10, (segment, isLast) => <'Vector(<0>, <1>, <2>)<3>',
            NodeIndexFromID(segment.Node1), NodeIndexFromID(segment.Node2), 0,
            isLast ? '); ' : ', '>);
    });
}

void ExportMapToOstw()
{
    # Introduction message
    LogToInspector(<'Place the following text into a file named \"<0>.jsonc\":', CurrentMap()> + sep + '\n/*');

    # Export Ostw nodes
    LogToInspector('*/ { "nodes": [ /*');
    ExportArray(Nodes, 10, (wn, isLast) => ExportJsonVector(wn.Node.Position, isLast));
    # Export Ostw segments
    LogToInspector('*/ ], "segments": [ /*');
    ExportArray(Segments, 10, (seg, isLast) => <'{"x": <0>, "y": <1>, "z": 0}', NodeIndexFromID(seg.Node1), NodeIndexFromID(seg.Node2)>);
    # Export Ostw attributes
    LogToInspector('*/ ], "attributes": [ /*');
    ExportArray(Attributes, 10, (attr, isLast) => <'{"x": <0>, "y": <1>, "z": 0}', NodeIndexFromID(attr.Node1), NodeIndexFromID(attr.Node2)>);
    # Conclude JSON
    LogToInspector('*/ ] }' + sep + '\n');

    # This exported code should be placed in the overpy file.
    LogToInspector('Place the following text into your ostw script:' + sep + ExportOstwDataSet("nodes"));
    LogToInspector('*/' + ExportOstwDataSet("segments"));
    LogToInspector('*/' + ExportOstwDataSet("attributes"));
}

void ExportMapToOverpy()
{
    # Introduction message
    LogToInspector(<'Place the following text into a file named \"<0>.js\":', CurrentMap()> + sep + '\n/*');

    # Export Overpy nodes
    LogToInspector('*/ const n = [ /*');
    ExportArray(Nodes, 10, (wn, isLast) => <'vect(<0>, <1>, <2>)<3>',
        wn.Node.Position.X, wn.Node.Position.Y, wn.Node.Position.Z, isLast ? '' : ','>);
    LogToInspector('*/ ]; /*');

    # Export Overpy segments
    LogToInspector('*/ const s = [ /*');
    ExportArray(Segments, 10, (seg, isLast) => <'vect(<0>, <1>, 0)<2>',
        NodeIndexFromID(seg.Node1), NodeIndexFromID(seg.Node2), isLast ? '' : ','>);
    LogToInspector('*/ ]; /*');
    
    # Export Overpy attributes
    LogToInspector('*/ const a = [ /*');
    ExportArray(Attributes, 10, (attr, isLast) => <'vect(<0>, <1>, 0)<2>',
        NodeIndexFromID(attr.Node1), NodeIndexFromID(attr.Node2), isLast ? '' : ','>);
    LogToInspector('*/ ]; /*');

    # Javascript -> overpy rules
    LogToInspector('*/ function load(name, array) { return ( /*');
    LogToInspector(<'*/ `rule "GENERATED <0> ${name}":\n` + /*', CurrentMap()>);
    LogToInspector(<'*/ `    @Condition getCurrentMap() == Map.<0>\n` + /*', mapNameToOverpyName(CurrentMap())>);
    LogToInspector(<'*/ `    loadedMap_${name} = [${array.join(\',\')}]\n`); } /*'>);
    LogToInspector('*/ load("nodes", n) + /*');
    LogToInspector('*/ load("segments", s) + /*');
    LogToInspector('*/ load("attributes", a) /*' + sep + '\n');

    # This exported code should be placed in the overpy file.
    LogToInspector('Place the following text into your overpy script:' + sep + <'*/\n#!define loadMap() __script__("<0>.js")\nloadMap() /*', CurrentMap()>);
}

rule: 'Test'
Event.OngoingPlayer
if (button(Button.Melee))
if (host == eventPlayer)
{
    EnableInspector();
    # Start block comment chain
    LogToInspector('/*');
    ExportMapToOstw();
    // ExportCore2();
    // ExportMap2();
    // ExportRules(OutputLanguage.Workshop);
    DisableInspector();
}

void ExportCorePathfinderComponents(Number globalRange, Number playerRange, Number subroutineRange) playervar "EXPORT: decompresser to workshop"
{
    EnableInspector();

    // Variables:
    // ~~global.pathfinder_nodes~~
    // ~~global.pathfinder_attributes~~
    // *global.pathfinder_compressed
    // global.pathfinder_matcher
    // global.pathfinder_parent_map
    // global.pathfinder_i_node
    // global.pathfinder_current_node_array
    // global.pathfinder_i_string
    // global.pathfinder_index_mapper

    // Subroutine params:
    // global.pathfind_players
    // global.pathfind_destination
    
    // Player variables:
    // player.pf_path_index (parent array)
    // player.pf_destination
    // player.pf_update_path
    // player.pf_current_node
    // player.pf_attributes

    // Subroutines:
    // pathfind

    Number gr: globalRange;
    Number pr: playerRange;
    # Variables
    LogToInspector(<'variables { global: <0>: pathfinder_compressed <1>: pathfinder_matcher <2>: pathfinder_parent_map <3>: pathfinder_i_node /*', gr, gr + 1, gr + 2, gr + 3>);
    LogToInspector(<'*/ <0>: pathfinder_current_node_array <1>: pathfinder_i_string <2>: pathfinder_index_mapper <3>: pathfinder_nodes /*', gr + 4, gr + 5, gr + 6, gr + 7>);
    LogToInspector(<'*/ <0>: pathfinder_attributes <1>: pathfind_players <2>: pathfind_destination /*', gr + 8, gr + 9, gr + 10>);
    LogToInspector(<'*/ player: <0>: pf_path_index <1>: pf_destination <2>: pf_update_path <3>: pf_current_node <4>: pf_attributes } /*', pr, pr + 1, pr + 2, pr + 3, pr + 4>);
    # Subroutines
    LogToInspector(<'*/ subroutines { <0>: pathfind } /*', subroutineRange>);
    # Add rule and event
    LogToInspector('*/ rule(\"GENERATED: decompress map\") { event { Ongoing - Global; } /*');
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Wait for pathfinder_compressed to contain a value before starting.
    LogToInspector('*/     global.pathfinder_compressed != Null; /*');
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Create the Matcher
    LogToInspector('*/     global.pathfinder_matcher = Array( /*');
    MinWait();
    // todo: splice bake matcher to only export as much as required. 
    # Add matcher elements
    ExportArray(bakeMatcher, 20, (char, isLast) => <'Custom String(\"<0>\")<1>', char, isLast ? '); ' : ', '>);
    # Initialize pathfinder_parent_map
    LogToInspector('*/     global.pathfinder_parent_map = Empty Array; /*');
    # Start the node loop
    LogToInspector('*/     For Global Variable(pathfinder_i_node, 0, Count Of(global.pathfinder_compressed), 1); /*');
    # Initialize global.pathfinder_current_node_array
    LogToInspector('*/         global.pathfinder_current_node_array = Empty Array; /*');
    # Start the string loop
    LogToInspector('*/         For Global Variable(pathfinder_i_string, 0, Count Of(global.pathfinder_compressed[global.pathfinder_i_node]), 1); /*');
    # Initialize the index matcher
    LogToInspector('*/             global.pathfinder_index_mapper = Empty Array; /*');
    # Stretch index matcher to length of string.
    LogToInspector('*/             global.pathfinder_index_mapper[String Length(global.pathfinder_compressed[global.pathfinder_i_node] /*');
    LogToInspector('*/                 [global.pathfinder_i_string])] = 0; /*');
    # Append the stub to the current node array.
    LogToInspector('*/             Modify Global Variable(pathfinder_current_node_array, Append To Array, Mapped Array( /*');
    LogToInspector('*/                 global.pathfinder_index_mapper, Index Of Array Value(global.pathfinder_matcher, /*');
    LogToInspector('*/                 String Slice(global.pathfinder_compressed[global.pathfinder_i_node][global.pathfinder_i_string], /*');
    LogToInspector('*/                 Current Array Index, 1)) - 1)); /*'); // - 1 is adjustment
    # Wait
    LogToInspector('*/             Wait(0.016, Ignore Condition)');
    # End the string loop
    LogToInspector('*/         end; /*');
    # Add pathfinder_current_node_array to pathfinder_parent_map
    LogToInspector('*/     Modify Global Variable(pathfinder_parent_map, Append To Array, Array(Global.pathfinder_current_node_array)); /*');
    # Wait
    LogToInspector('*/         Wait(0.016, Ignore Condition)');
    # End the node loop
    LogToInspector('*/     end; /*');
    # End action & rule block
    LogToInspector('*/ } } /*');
    MinWait();

    # Pathfind subroutine
    LogToInspector('*/ rule(\"GENERATED: pathfind Subroutine\") { event { subroutine; pathfind; } /*');
    # Actions
    LogToInspector('*/ actions { /*');
    // todo: should we set the pathmap that the player is using?
    # Set player's path index
    LogToInspector('*/     global.pathfind_players.pf_path_index = Index Of Array Value(global.pathfinder_nodes, ' + 'First Of(Sorted Array(global.pathfinder_nodes, Distance Between(Current Array Element, ' + 'Global.pathfind_destination)))); /*');
    # Set each player's destination
    LogToInspector('*/     global.pathfind_players.pf_destination = global.pathfind_destination; /*');
    # Update each player's path
    LogToInspector('*/     global.pathfind_players.pf_update_path = True; /*');
    # End action & rule block
    LogToInspector('*/ } } /*');
    MinWait();

    # Player init rule
    LogToInspector('*/ rule(\"GENERATED: PLAYER: update path\") { event { Ongoing - Each Player; All; All; } /*');
    # Start actions
    LogToInspector('*/ actions { /*');
    # Init pf_path_index
    LogToInspector('*/     Event Player.pf_path_index = -1; /*');
    # End action & rule block
    LogToInspector('*/ } } /*');
    MinWait();

    # Player Update Path rule
    LogToInspector('*/ rule(\"GENERATED: PLAYER: update path\") { event { Ongoing - Each Player; All; All; } /*');
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Execute when pf_update_path
    LogToInspector('*/     Event Player.pf_update_path == True; /*');
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Update current node
    LogToInspector('*/     Event Player.pf_current_node = Index Of Array Value(global.pathfinder_nodes, ' + 'First Of(Sorted Array(global.pathfinder_nodes, Distance Between(Current Array Element, ' + 'Position Of(Event Player))))); /*');
    # Throttle
    LogToInspector('*/     Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), /*');
    LogToInspector('*/         Event Player.pf_current_node == -1 ? Event Player.pf_destination : global.pathfinder_nodes[ /*');
    LogToInspector('*/         Event Player.pf_current_node]), 1, To World, Replace existing throttle, Direction and Magnitude); /*');
    # Reset pf_update_path
    LogToInspector('*/     Event Player.pf_update_path = False; /*');
    # End action & rule block
    LogToInspector('*/ } } /*');
    MinWait();

    # Player Next Node rule
    LogToInspector('*/ rule(\"GENERATED: PLAYER: next node\") { event { Ongoing - Each Player; All; All; } /*');
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Execute when node reached
    LogToInspector('*/     Distance Between(Position Of(Event Player), Event Player.pf_current_node == -1 ? /*');
    LogToInspector('*/         Event Player.pf_destination : Global.pathfinder_nodes[Event Player.pf_current_node]) <= 0.400; /*');
    # Is pathfinding?
    LogToInspector('*/     Event Player.pf_path_index != -1; /*');
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Is destination reached?
    LogToInspector('*/     If (Event Player.pf_current_node == -1); /*');
    # Destination reached, stop moxing.
    LogToInspector('*/         Stop Throttle In Direction(Event Player); /*');
    # Stop pathfinding.
    LogToInspector('*/         Event Player.pf_path_index = -1; /*');
    # Set next node
    LogToInspector('*/     Else; /*');
    # Set current attribute
    LogToInspector('*/         Event Player.pf_attributes = Mapped Array(Filtered Array(Global.pathfinder_attributes, /*');
    LogToInspector('*/             X Component Of(Current Array Element) == Event Player.pf_current_node && /*');
    LogToInspector('*/             Y Component Of(Current Array Element) == global.pathfinder_parent_map[Event Player.pf_path_index] /*');
    LogToInspector('*/             [Event Player.pf_current_node]), Z Component Of(Current Array Element)); /*');
    # Set current node
    LogToInspector('*/         Event Player.pf_current_node = global.pathfinder_parent_map[Event Player.pf_path_index]' + '[Event Player.pf_current_node]; /*');
    LogToInspector('*/     End; /*');
    # Loop if needed
    LogToInspector('*/     Wait(0.250, Ignore Condition); /*');
    LogToInspector('*/     Loop If Condition Is True(); /*');
    # End action & rule block
    LogToInspector('*/ } } /*');

    DisableInspector();
}

playervar String exportArrayStub;
playervar Number exportArrayNumA;
playervar Number exportArrayNumB;
void ExportArray<T>(in T[] array, in Number step, const (T, Boolean) => String valueToString)
{
    for (exportArrayNumA = 0; array.Length; step) {
        exportArrayStub = '';
        for (exportArrayNumB = exportArrayNumA; Min(exportArrayNumA + step, array.Length); 1) {
            exportArrayStub = exportArrayStub + valueToString(array[exportArrayNumB], exportArrayNumB == array.Length - 1);
        }
        LogToInspector('*/{0}/*'.Format([exportArrayStub]));
        MinWait();
    }
}

void ExportMapBlock(in String blockName, const () => void exportActions)
{
    # Attributes rule
    LogToInspector('*/ rule(\"GENERATED: {0} {1}\") { event { Ongoing - Global; } /*'.Format([CurrentMap(), blockName]));
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Make sure this is the correct map
    LogToInspector(mapCondition);
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Export inner actions
    exportActions();
    # End action & rule block
    LogToInspector('*/ } } /*');
}

String ExportJsonVector(in Vector vector, in Boolean isLast)
{
    return <'{"x":<0>, "y":<1>, "z":<2>}<3>', vector.X, vector.Y, vector.Z, isLast ? '' : ', '>;
}

String ExportOstwDataSet(in String setName)
{
    return <'\nrule: "GENERATED <0> <1>"\n', CurrentMap(), setName> +
        <'if (CurrentMap() == Map.<0>) {\n', mapNameToOstwName(CurrentMap())> +
        <'    loadedMap.<1> = import("<0>.jsonc").<1>;\n} /*', CurrentMap(), setName>;
}

void ExportStatement(in OutputLanguage language, in String workshop, in String deltinscript, in String overpy)
{
    LogToInspector([workshop, deltinscript, overpy][language]);
}

void ExportAction(in OutputLanguage language, in String workshop, in String deltinScript, in String overpy)
{
    LogToInspector("*/{0} /*".Format([[" " + workshop, "     " + deltinScript, "\n    " + overpy][language]]));
}

String mapCondition: '*/     Current Map == Map({0}); /*'.Format([CurrentMap()]);