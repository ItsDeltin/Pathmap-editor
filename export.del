import 'main.del';
import 'overpy.del';

enum OutputLanguage
{
    Workshop,
    OSTW,
    OverPy
}

void ExportMenu() 'EXPORT: create export menu'
{
    setMainLabel("main / export");
    
    buttonCollectionMain += createButton(
        label: "┏━ Language ━┓",
        posX: 1.5,
        posY: .6,
        defaultColor: Color.White,
        interactable: false
    );
    buttonCollectionMain += createButton(
        label: "Workshop",
        posX: 1.5,
        posY: .3,
        defaultColor: Color.Green,
        primaryAction: MenuAction.ExportWorkshop
    );
    buttonCollectionMain += createButton(
        label: "OSTW",
        posX: 1.5,
        posY: 0.,
        defaultColor: Color.SkyBlue,
        primaryAction: MenuAction.ExportOstw
    );
    buttonCollectionMain += createButton(
        label: "Overpy",
        posX: 1.5,
        posY: -.3,
        defaultColor: Color.Yellow,
        primaryAction: MenuAction.ExportOverpy
    );
}

rule: 'EXPORT: open export menu'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.Export)
{
    SetMenuState(MenuState.Export);
}

rule: 'EXPORT: Workshop'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.ExportWorkshop)
{
    ExportRules(OutputLanguage.Workshop);
}

rule: 'EXPORT: OSTW'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.ExportOstw)
{
    ExportRules(OutputLanguage.OSTW);
}

rule: 'EXPORT: OverPy'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.ExportOverpy)
{
    ExportRules(OutputLanguage.OverPy);
}

void ExportRules(OutputLanguage lang) playervar 'EXPORT: Export'
{
    // OngoingPlayer is not vital, it's just so we can use player variables here
    // since we are clean out of global ones :')
    EnableInspector();
    SmallMessage(AllPlayers(), 'Exporting rules');
    
    Boolean is_ow: lang == OutputLanguage.Workshop;
    Boolean is_ostw: lang == OutputLanguage.OSTW;
    Boolean is_overpy: lang == OutputLanguage.OverPy;

    LogToInspector('\n\n/*********\n* BEGIN *\n*********');
    LogToInspector('* You can use the following regex expression to remove the timestamps:');
    LogToInspector('* \"^\\[[0-9]{{2}}:[0-9]{{2}}:[0-9]{{2}}\\] \*\/ \"');

    for(define i = 0; Rules.Length; 1) {
        # Rule syntax
        ExportStatement(lang,
            '*/ rule(\"Custom Pathfinding Rule #{0}\") { /*'.Format([i + 1]),
            '*/ rule: \"Custom Pathfinding Rule #{0}\" /*'.Format([i + 1]),
            '*/\nrule \"Custom Pathfinding Rule #{0}\": @Event eachPlayer /*'.Format([i + 1])
        );

        Number numberOfEnabledHeroes! = Rules[i].EnabledHeroes.FilteredArray(x => x).Length;
        Number firstEnabledHero! = Rules[i].EnabledHeroes.IndexOf(true);

        # Add event (ow)
        if (is_ow) {
            LogToInspector(<'*/ event { Ongoing - Each Player; All; <0>; } /*',
                numberOfEnabledHeroes != 1 ? 'All' : AllHeroes()[firstEnabledHero]>);
        }
        # Add event (ostw)
        else if (is_ostw) {
            LogToInspector('*/ Event.OngoingPlayer /*');
            if (numberOfEnabledHeroes == 1) {
                LogToInspector(<'*/ Player.<0> /*', <'<0>',
                    AllHeroes()[firstEnabledHero]>
                    .Replace(' ', '') // wrecking ball/junker queen
                    .Replace(':', '') // soldier
                    .Replace('ú', '') // lucio
                    .Replace('.', '') // dva
                    .Replace('ö', '')>); // torb
            }
        }
        # Add event (overpy)
        else if (is_overpy && numberOfEnabledHeroes == 1) {
            LogToInspector(<'*/\n    @hero <0> /*',
                // todo: this needs to be in the same order as the heroes in AllHeroes().
                ['ana', 'ashe', 'baptiste', 'bastion', 'brigitte', 'doomfist', 'dva', 'echo', 'genji', 'hammond', 'hanzo',
                'junkerQueen', 'junkrat', 'kiriko', 'lucio', 'mccree', 'mei', 'mercy', 'moira', 'orisa', 'pharah', 'reaper',
                'reinhardt', 'roadhog', 'sigma', 'sojourn', 'soldier', 'sombra', 'torbjorn', 'tracer', 'widowmaker', 'winston',
                'zarya', 'zenyatta', 'ramattra'][firstEnabledHero]>);
        } 

        # Workshop code
        if (lang == OutputLanguage.Workshop) {
            LogToInspector('*/ conditions { /*');
            LogToInspector('*/     Array Contains(Event Player.pfAttributes, {0}) == True; /*'.Format([Rules[i].ExecutesOnAttribute]));
            LogToInspector('*/ } actions { /*');
        }
        # OSTW code
        else if (lang == OutputLanguage.OSTW) {
            LogToInspector('*/ if (pfAttributes.Contains({0})) /*'.Format([Rules[i].ExecutesOnAttribute]));
            LogToInspector('*/ { /*');
        }
        # Overpy code
        else if (lang == OutputLanguage.OverPy) {
            // TODO
            LogToInspector('*/\n    @Condition pfAttributes.contains({0}) /*'.Format([Rules[i].ExecutesOnAttribute]));
        }            
        
        # Loop through each action in the rule.
        for(define a = 0; Rules[i].Actions.Length; 1) {
            # Extract the action ID.
            define export = Rules[i].Actions[a].Export;
            define actionID: export.X;

            # Wait
            if (actionID == 0) {
                ExportAction(lang,
                    <'Wait(<0>, Ignore Condition);', export.Y>,
                    <'Wait(<0>);', export.Y>,
                    <'wait(<0>)', export.Y>);
            }
            # Jump
            else if (actionID == 1) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Jump));',
                    'PressButton(EventPlayer(), Button.Jump);',
                    'eventPlayer.forceButtonPress(Button.JUMP)');
            }
            # Start holding jump
            else if (actionID == 2) {
                ExportAction(lang,
                    'Start Holding Button(Event Player, Button(Jump));',
                    'StartHoldingButton(EventPlayer(), Button.Jump);',
                    'eventPlayer.startForcingButton(Button.JUMP)');
            }
            # Stop holding jump
            else if (actionID == 3) {
                ExportAction(lang,
                    'Stop Holding Button(Event Player, Button(Jump));',
                    'StopHoldingButton(EventPlayer(), Button.Jump);',
                    'eventPlayer.stopForcingButton(Button.JUMP)');
            }
            # Ability 1
            else if (actionID == 4) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Ability 1));',
                    'PressButton(EventPlayer(), Button.Ability1);',
                    'eventPlayer.forceButtonPress(Button.ABILITY_1)');
            }
            # Ability 2
            else if (actionID == 5) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Ability 2));',
                    'PressButton(EventPlayer(), Button.Ability2);',
                    'eventPlayer.forceButtonPress(Button.ABILITY_2)');
            }
            # Melee
            else if (actionID == 6) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Melee));',
                    'PressButton(EventPlayer(), Button.Melee);',
                    'eventPlayer.forceButtonPress(Button.MELEE)');
            }
            # Primary fire
            else if (actionID == 7) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Primary Fire));',
                    'PressButton(EventPlayer(), Button.PrimaryFire);',
                    'eventPlayer.forceButtonPress(Button.PRIMARY_FIRE)');
            }
            # Secondary fire
            else if (actionID == 8) {
                ExportAction(lang,
                    'Press Button(Event Player, Button(Secondary Fire));',
                    'PressButton(EventPlayer(), Button.SecondaryFire);',
                    'eventPlayer.forceButtonPress(Button.SECONDARY_FIRE)');
            }
            # Stop walking
            else if (actionID == 9) {
                ExportAction(lang,
                    'Stop Throttle In Direction(Event Player);',
                    'StopThrottleInDirection();',
                    'eventPlayer.stopThrottleInDirection()');
            }
            # Walk to destination
            else if (actionID == 10) {
                ExportAction(lang, "uhh;", "uhh();", "uhh()");
            }
            # Look at floor
            else if (actionID == 11) {
                ExportAction(lang,
                    "Start Facing(Event Player, Direction From Angles(Horizontal Facing Angle Of(Event Player), 89), 1000, To World, None);",
                    "StartFacing(EventPlayer(), DirectionFromAngles(HorizontalFacingAngleOf(), 89), 1000, Relative.ToWorld, FacingRev.None);",
                    "eventPlayer.startFacing(angleToDirection(eventPlayer.getHorizontalFacingAngle(), 89), 1000, Relativity.TO_WORLD, FacingReeval.NONE)");
            }
            # Look at destination
            else if (actionID == 12) {
                ExportAction(lang, "uhh;", "uhh();", "uhh()");
            }

            MinWait();
        }

        # End rule & actions for the c-like languages 
        if (lang == OutputLanguage.Workshop)
            LogToInspector('*/ } } /*');
        else if (lang == OutputLanguage.OSTW)
            LogToInspector('*/ } /*');
        
        MinWait();
    }

    LogToInspector('*/');

    SmallMessage(AllPlayers(), "Rules exported!");
    DisableInspector();
}

void ExportCompressedDataToWorkshop() playervar "EXPORT: compressed data to workshop" 
{
    // This function assumes MakeBake() was already executed.

    EnableInspector();
    // String variableCompatibleMapName = '{0}'.Format([CurrentMap()])
    //     .Replace(' ', '')
    //     .Replace('(', '')
    //     .Replace(')', '')
    //     .Replace(':', '');

    # Add rule and event
    LogToInspector('*/ rule(\"GENERATED: {0} compressed map data\") { event { Ongoing - Global; } /*'.Format([CurrentMap()]));
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Make sure this is the correct map
    LogToInspector(mapCondition);
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Set compressed data
    LogToInspector('*/     global.pathfinder_compressed = Array(Array(Custom String( /*');

    # For each node
    for (define a = 0; bakeResult.Length; 1) {
        # Add each stub
        for (define b = 0; bakeResult[a].Length; 1) {
            # String value
            LogToInspector('*/\"{0}\"/*'.Format([bakeResult[a][b]]));
            # End string
            LogToInspector('*/         ){0} /*'.Format([
                b < bakeResult[a].Length - 1 ? ', Custom String(' :
                a < bakeResult.Length - 1 ? '), Array(Custom String(' : '));'
            ]));
            MinWait();
        }
        MinWait();
    }
    # End action & rule block
    LogToInspector('*/ } } /*');

    ExportNodes();
    ExportAttributes();
    ExportSegments();
    
    DisableInspector();
}

void ExportNodes()
{
    # Nodes rule
    LogToInspector('*/ rule(\"GENERATED: {0} nodes\") { event { Ongoing - Global; } /*'.Format([CurrentMap()]));
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Make sure this is the correct map
    LogToInspector(mapCondition);
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Set pathfinder_nodes
    LogToInspector('*/     global.loadedMap_nodes = Array( /*');
    # For each node
    for (Number a = 0; Nodes.Length; 10) {
        String stub = '';
        for (Number b = a; Min(a + 10, Nodes.Length); 1) {
            define vector = Nodes[b].Node.Position;
            stub = stub + <'Vector<0><1>',
                vector,
                b < Nodes.Length - 1 ? ', ' : ');'>;
        }
        LogToInspector('*/{0}/*'.Format([stub]));
        MinWait();
    }
    # End action & rule block
    LogToInspector('*/ } } /*');
}

void ExportAttributes()
{
    # Attributes rule
    LogToInspector('*/ rule(\"GENERATED: {0} attributes\") { event { Ongoing - Global; } /*'.Format([CurrentMap()]));
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Make sure this is the correct map
    LogToInspector(mapCondition);
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Set pathfinder_attributes
    LogToInspector('*/     global.loadedMap_attributes = Array( /*');
    # For each attribute
    ExportArray(Attributes, 10, (attribute, isLast) => <'Vector(<0>, <1>, <2>)<3>',
        NodeIndexFromID(attribute.Node1), NodeIndexFromID(attribute.Node2), attribute.Value,
        isLast ? '); ' : ', '>);
    # End action & rule block
    LogToInspector('*/ } } /*');
}

void ExportSegments()
{
    ExportMapBlock('segments', () => {
        # Set pathfinder_segments
        LogToInspector('*/     global.loadedMap_paths = Array( /*');
        # For each attribute
        ExportArray(Segments, 10, (segment, isLast) => <'Vector(<0>, <1>, <2>)<3>',
            NodeIndexFromID(segment.Node1), NodeIndexFromID(segment.Node2), 0,
            isLast ? '); ' : ', '>);
    });
}

void ExportMapAsJson()
{
    LogToInspector('*/ { "nodes": [ /*');
    ExportArray(Nodes, 10, (wn, isLast) => ExportJsonVector(wn.Node.Position, isLast));
    LogToInspector('*/ ], "segments": [ /*');
    ExportArray(Segments, 10, (seg, isLast) => <'{"x": <0>, "y": <1>, "z": 0}', NodeIndexFromID(seg.Node1), NodeIndexFromID(seg.Node2)>);
    LogToInspector('*/ ], "attributes": [ /*');
    ExportArray(Attributes, 10, (attr, isLast) => <'{"x": <0>, "y": <1>, "z": 0}', NodeIndexFromID(attr.Node1), NodeIndexFromID(attr.Node2)>);
    LogToInspector('*/ ] } /*');
}

void ExportMapToOverpy()
{
    String sep: '\n⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯';

    # Introduction message
    LogToInspector(<'Place the following text into a file named \"<0>.js\":', CurrentMap()> + sep + '\n/*');

    # Export Overpy nodes
    LogToInspector('*/ const n = [ /*');
    ExportArray(Nodes, 10, (wn, isLast) => <'vect(<0>, <1>, <2>)<3>',
        wn.Node.Position.X, wn.Node.Position.Y, wn.Node.Position.Z, isLast ? '' : ','>);
    LogToInspector('*/ ]; /*');

    # Export Overpy segments
    LogToInspector('*/ const s = [ /*');
    ExportArray(Segments, 10, (seg, isLast) => <'vect(<0>, <1>, 0)<2>',
        NodeIndexFromID(seg.Node1), NodeIndexFromID(seg.Node2), isLast ? '' : ','>);
    LogToInspector('*/ ]; /*');
    
    # Export Overpy attributes
    LogToInspector('*/ const a = [ /*');
    ExportArray(Attributes, 10, (attr, isLast) => <'vect(<0>, <1>, 0)<2>',
        NodeIndexFromID(attr.Node1), NodeIndexFromID(attr.Node2), isLast ? '' : ','>);
    LogToInspector('*/ ]; /*');

    # Javascript -> overpy rules
    LogToInspector('*/ function load(name, array) { return ( /*');
    LogToInspector(<'*/ `rule "GENERATED <0> ${name}":\n` + /*', CurrentMap()>);
    LogToInspector(<'*/ `    @Condition getCurrentMap() == Map.<0>\n` + /*', mapNameToOverpyName(CurrentMap())>);
    LogToInspector(<'*/ `    loadedMap_${name} = [${array.join(\',\')}]\n`); } /*'>);
    LogToInspector('*/ load("nodes", n) + /*');
    LogToInspector('*/ load("segments", s) + /*');
    LogToInspector('*/ load("attributes", a) /*' + sep + '\n');

    # This exported code should be placed in the overpy file.
    LogToInspector('Place the following text into your overpy script:' + sep + <'*/\n#!define loadMap() __script__("<0>.js")\nloadMap() /*', CurrentMap()>);
}

rule: 'Test'
Event.OngoingPlayer
if (button(Button.Melee))
if (host == eventPlayer)
{
    // MakeBake();
    // ExportCorePathfinderComponents(0, 0, 0);
    // ExportCompressedDataToWorkshop();
    EnableInspector();
    # Start block comment chain
    LogToInspector('/*');
    ExportMapToOverpy();
    // ExportCore2();
    // ExportMap2();
    // ExportRules(OutputLanguage.Workshop);
    DisableInspector();
}

void ExportCorePathfinderComponents(Number globalRange, Number playerRange, Number subroutineRange) playervar "EXPORT: decompresser to workshop"
{
    EnableInspector();

    // Variables:
    // ~~global.pathfinder_nodes~~
    // ~~global.pathfinder_attributes~~
    // *global.pathfinder_compressed
    // global.pathfinder_matcher
    // global.pathfinder_parent_map
    // global.pathfinder_i_node
    // global.pathfinder_current_node_array
    // global.pathfinder_i_string
    // global.pathfinder_index_mapper

    // Subroutine params:
    // global.pathfind_players
    // global.pathfind_destination
    
    // Player variables:
    // player.pf_path_index (parent array)
    // player.pf_destination
    // player.pf_update_path
    // player.pf_current_node
    // player.pf_attributes

    // Subroutines:
    // pathfind

    Number gr: globalRange;
    Number pr: playerRange;
    # Variables
    LogToInspector(<'variables { global: <0>: pathfinder_compressed <1>: pathfinder_matcher <2>: pathfinder_parent_map <3>: pathfinder_i_node /*', gr, gr + 1, gr + 2, gr + 3>);
    LogToInspector(<'*/ <0>: pathfinder_current_node_array <1>: pathfinder_i_string <2>: pathfinder_index_mapper <3>: pathfinder_nodes /*', gr + 4, gr + 5, gr + 6, gr + 7>);
    LogToInspector(<'*/ <0>: pathfinder_attributes <1>: pathfind_players <2>: pathfind_destination /*', gr + 8, gr + 9, gr + 10>);
    LogToInspector(<'*/ player: <0>: pf_path_index <1>: pf_destination <2>: pf_update_path <3>: pf_current_node <4>: pf_attributes } /*', pr, pr + 1, pr + 2, pr + 3, pr + 4>);
    # Subroutines
    LogToInspector(<'*/ subroutines { <0>: pathfind } /*', subroutineRange>);
    # Add rule and event
    LogToInspector('*/ rule(\"GENERATED: decompress map\") { event { Ongoing - Global; } /*');
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Wait for pathfinder_compressed to contain a value before starting.
    LogToInspector('*/     global.pathfinder_compressed != Null; /*');
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Create the Matcher
    LogToInspector('*/     global.pathfinder_matcher = Array( /*');
    MinWait();
    // todo: splice bake matcher to only export as much as required. 
    # Add matcher elements
    ExportArray(bakeMatcher, 20, (char, isLast) => <'Custom String(\"<0>\")<1>', char, isLast ? '); ' : ', '>);
    # Initialize pathfinder_parent_map
    LogToInspector('*/     global.pathfinder_parent_map = Empty Array; /*');
    # Start the node loop
    LogToInspector('*/     For Global Variable(pathfinder_i_node, 0, Count Of(global.pathfinder_compressed), 1); /*');
    # Initialize global.pathfinder_current_node_array
    LogToInspector('*/         global.pathfinder_current_node_array = Empty Array; /*');
    # Start the string loop
    LogToInspector('*/         For Global Variable(pathfinder_i_string, 0, Count Of(global.pathfinder_compressed[global.pathfinder_i_node]), 1); /*');
    # Initialize the index matcher
    LogToInspector('*/             global.pathfinder_index_mapper = Empty Array; /*');
    # Stretch index matcher to length of string.
    LogToInspector('*/             global.pathfinder_index_mapper[String Length(global.pathfinder_compressed[global.pathfinder_i_node] /*');
    LogToInspector('*/                 [global.pathfinder_i_string])] = 0; /*');
    # Append the stub to the current node array.
    LogToInspector('*/             Modify Global Variable(pathfinder_current_node_array, Append To Array, Mapped Array( /*');
    LogToInspector('*/                 global.pathfinder_index_mapper, Index Of Array Value(global.pathfinder_matcher, /*');
    LogToInspector('*/                 String Slice(global.pathfinder_compressed[global.pathfinder_i_node][global.pathfinder_i_string], /*');
    LogToInspector('*/                 Current Array Index, 1)) - 1)); /*'); // - 1 is adjustment
    # Wait
    LogToInspector('*/             Wait(0.016, Ignore Condition)');
    # End the string loop
    LogToInspector('*/         end; /*');
    # Add pathfinder_current_node_array to pathfinder_parent_map
    LogToInspector('*/     Modify Global Variable(pathfinder_parent_map, Append To Array, Array(Global.pathfinder_current_node_array)); /*');
    # Wait
    LogToInspector('*/         Wait(0.016, Ignore Condition)');
    # End the node loop
    LogToInspector('*/     end; /*');
    # End action & rule block
    LogToInspector('*/ } } /*');
    MinWait();

    # Pathfind subroutine
    LogToInspector('*/ rule(\"GENERATED: pathfind Subroutine\") { event { subroutine; pathfind; } /*');
    # Actions
    LogToInspector('*/ actions { /*');
    // todo: should we set the pathmap that the player is using?
    # Set player's path index
    LogToInspector('*/     global.pathfind_players.pf_path_index = Index Of Array Value(global.pathfinder_nodes, ' + 'First Of(Sorted Array(global.pathfinder_nodes, Distance Between(Current Array Element, ' + 'Global.pathfind_destination)))); /*');
    # Set each player's destination
    LogToInspector('*/     global.pathfind_players.pf_destination = global.pathfind_destination; /*');
    # Update each player's path
    LogToInspector('*/     global.pathfind_players.pf_update_path = True; /*');
    # End action & rule block
    LogToInspector('*/ } } /*');
    MinWait();

    # Player init rule
    LogToInspector('*/ rule(\"GENERATED: PLAYER: update path\") { event { Ongoing - Each Player; All; All; } /*');
    # Start actions
    LogToInspector('*/ actions { /*');
    # Init pf_path_index
    LogToInspector('*/     Event Player.pf_path_index = -1; /*');
    # End action & rule block
    LogToInspector('*/ } } /*');
    MinWait();

    # Player Update Path rule
    LogToInspector('*/ rule(\"GENERATED: PLAYER: update path\") { event { Ongoing - Each Player; All; All; } /*');
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Execute when pf_update_path
    LogToInspector('*/     Event Player.pf_update_path == True; /*');
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Update current node
    LogToInspector('*/     Event Player.pf_current_node = Index Of Array Value(global.pathfinder_nodes, ' + 'First Of(Sorted Array(global.pathfinder_nodes, Distance Between(Current Array Element, ' + 'Position Of(Event Player))))); /*');
    # Throttle
    LogToInspector('*/     Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), /*');
    LogToInspector('*/         Event Player.pf_current_node == -1 ? Event Player.pf_destination : global.pathfinder_nodes[ /*');
    LogToInspector('*/         Event Player.pf_current_node]), 1, To World, Replace existing throttle, Direction and Magnitude); /*');
    # Reset pf_update_path
    LogToInspector('*/     Event Player.pf_update_path = False; /*');
    # End action & rule block
    LogToInspector('*/ } } /*');
    MinWait();

    # Player Next Node rule
    LogToInspector('*/ rule(\"GENERATED: PLAYER: next node\") { event { Ongoing - Each Player; All; All; } /*');
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Execute when node reached
    LogToInspector('*/     Distance Between(Position Of(Event Player), Event Player.pf_current_node == -1 ? /*');
    LogToInspector('*/         Event Player.pf_destination : Global.pathfinder_nodes[Event Player.pf_current_node]) <= 0.400; /*');
    # Is pathfinding?
    LogToInspector('*/     Event Player.pf_path_index != -1; /*');
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Is destination reached?
    LogToInspector('*/     If (Event Player.pf_current_node == -1); /*');
    # Destination reached, stop moxing.
    LogToInspector('*/         Stop Throttle In Direction(Event Player); /*');
    # Stop pathfinding.
    LogToInspector('*/         Event Player.pf_path_index = -1; /*');
    # Set next node
    LogToInspector('*/     Else; /*');
    # Set current attribute
    LogToInspector('*/         Event Player.pf_attributes = Mapped Array(Filtered Array(Global.pathfinder_attributes, /*');
    LogToInspector('*/             X Component Of(Current Array Element) == Event Player.pf_current_node && /*');
    LogToInspector('*/             Y Component Of(Current Array Element) == global.pathfinder_parent_map[Event Player.pf_path_index] /*');
    LogToInspector('*/             [Event Player.pf_current_node]), Z Component Of(Current Array Element)); /*');
    # Set current node
    LogToInspector('*/         Event Player.pf_current_node = global.pathfinder_parent_map[Event Player.pf_path_index]' + '[Event Player.pf_current_node]; /*');
    LogToInspector('*/     End; /*');
    # Loop if needed
    LogToInspector('*/     Wait(0.250, Ignore Condition); /*');
    LogToInspector('*/     Loop If Condition Is True(); /*');
    # End action & rule block
    LogToInspector('*/ } } /*');

    DisableInspector();
}

void ExportCore2()
{
    PrintStub('pathfinder/pathfind.ow', []);
}
void ExportMap2()
{
    ExportNodes();
    ExportSegments();
    ExportAttributes();
}

playervar String exportArrayStub;
playervar Number exportArrayNumA;
playervar Number exportArrayNumB;
void ExportArray<T>(in T[] array, in Number step, const (T, Boolean) => String valueToString)
{
    for (exportArrayNumA = 0; array.Length; step) {
        exportArrayStub = '';
        for (exportArrayNumB = exportArrayNumA; Min(exportArrayNumA + step, array.Length); 1) {
            exportArrayStub = exportArrayStub + valueToString(array[exportArrayNumB], exportArrayNumB == array.Length - 1);
        }
        LogToInspector('*/{0}/*'.Format([exportArrayStub]));
        MinWait();
    }
}

void ExportMapBlock(in String blockName, const () => void exportActions)
{
    # Attributes rule
    LogToInspector('*/ rule(\"GENERATED: {0} {1}\") { event { Ongoing - Global; } /*'.Format([CurrentMap(), blockName]));
    # Conditions
    LogToInspector('*/ conditions { /*');
    # Make sure this is the correct map
    LogToInspector(mapCondition);
    # Start actions
    LogToInspector('*/ } actions { /*');
    # Export inner actions
    exportActions();
    # End action & rule block
    LogToInspector('*/ } } /*');
}

String ExportJsonVector(in Vector vector, in Boolean isLast)
{
    return <'{"x":<0>, "y":<1>, "z":<2>}<3>', vector.X, vector.Y, vector.Z, isLast ? '' : ', '>;
}

void ExportStatement(in OutputLanguage language, in String workshop, in String deltinscript, in String overpy)
{
    LogToInspector([workshop, deltinscript, overpy][language]);
}

void ExportAction(in OutputLanguage language, in String workshop, in String deltinScript, in String overpy)
{
    LogToInspector("*/{0} /*".Format([[" " + workshop, "     " + deltinScript, "\n    " + overpy][language]]));
}

String mapCondition: '*/     Current Map == Map({0}); /*'.Format([CurrentMap()]);