import 'sandbox.del';
import 'place nodes.del';
import 'utility.del';
import 'history.del';
import 'freecam.del';
import 'settings.lobby';

struct Node
{
    public Number UniqueID;
    public Vector Position;
}

struct WorldNode
{
    public Node Node;
    public Boolean Selected = false;
    public Number Visibility = 0;
    public Any BallEffect = null;
    public Any RingEffect = null;

    public Color Color(): Highlighted() ?
        (Selected ? Color.Turquoise : Color.Blue) : // selected / highlighted
        (Selected ? Color.LimeGreen : Color.White);  // unselected / highlighted
    
    public Boolean Highlighted(): SelectedNodeID == Node.UniqueID;

    public Vector ShownPosition(): Node.Position + Up() * 1.3;

    public Boolean ValidTarget(): ShownPosition().DistanceTo(ray(eye, eye + facing * ShownPosition().DistanceTo(eye))) < NodeSize;
}

struct WorldSegment
{
    public Number ID;
    public Number Node1;
    public Number Node2;
    public Any Effect;
}

globalvar WorldNode[] Nodes = [];
globalvar WorldSegment[] Segments = [];

globalvar Number NodeUniqueID! = 1;
globalvar Number SegmentUniqueID! = 1;

Number NodeSize: 0.3;
Boolean AnyNodesSelected: Nodes.IsTrueForAny(node => node.Selected);

globalvar Number SelectedNodeIndex = -1;
globalvar Number SelectedNodeID = -1;

Number NodeIndexFromID(in Number id)
{
    for (define i = 0; Nodes.Length; 1)
        if (Nodes[i].Node.UniqueID == id)
            return i;
    
    return -1;
}

Number SegmentIndexFromID(in Number id)
{
    for (define i = 0; Segments.Length; 1)
        if (Segments[i].ID == id)
            return i;
    
    return -1;
}

void RemoveNodeByIndex(in Number index)
{
    DestroyEffect(Nodes[index].BallEffect);
    DestroyEffect(Nodes[index].RingEffect);
    Nodes.ModRemoveByIndex(index);
}

void RemoveSegmentByIndex(in Number index)
{
    DestroyEffect(Segments[index].Effect);
    Segments.ModRemoveByIndex(index);
}

rule: 'Main: Init'
{
    // Ball
    CreateEffect(
        AllPlayers().FilteredArray(p => SelectedNodeID == -1 && !host.cm_isInMenu),
        Effect.Sphere,
        Color.Orange,
        UpdateEveryFrame(watchPoint),
        0.2,
        EffectRev.VisibleToPositionRadiusAndColor);

    // Segment lines
    CreateBeamEffect(
        UpdateEveryFrame(connectingFromNode != -1 && SelectedNodeID != -1 ? AllPlayers() : null),
        BeamType.TorbjornTurretSightBeam,
        Nodes[connectingFromNode].ShownPosition(),
        Nodes[SelectedNodeIndex].ShownPosition(),
        Color.Team1,
        EffectRev.VisibleToPositionRadiusAndColor);
    CreateBeamEffect(
        UpdateEveryFrame(connectingFromNode != -1 && SelectedNodeID == -1 ? AllPlayers() : null),
        BeamType.TorbjornTurretSightBeam,
        Nodes[connectingFromNode].ShownPosition(),
        UpdateEveryFrame(watchPoint),
        Color.Team2,
        EffectRev.VisibleToPositionRadiusAndColor);
}

rule: 'Main: Selection loop'
if (Nodes.Length)
{
    SelectedNodeIndex = Nodes
        .Map((node, i) => i)
        .SortedArray(i => Nodes[i].ShownPosition().DistanceTo(eye))
        .FilteredArray(i => Nodes[i].ValidTarget())
        .First;
    
    SelectedNodeID = SelectedNodeIndex == -1 || !Nodes[SelectedNodeIndex].ValidTarget() ? -1 : Nodes[SelectedNodeIndex].Node.UniqueID;
    MinWait();
    LoopIfConditionIsTrue();
}

rule: 'Main: Renderer'
{
    // Nodes
    Number i;
    for (i = 0; Nodes.Length; 1)
    {
        // Not visible.
        if (!Nodes[i].Node.Position.IsInLineOfSight(eye))
        {
            if (Nodes[i].Visibility != 0)
            {
                DestroyEffect(Nodes[i].BallEffect);
                DestroyEffect(Nodes[i].RingEffect);
                Nodes[i].Visibility = 0;
            }
        }
        else
        {
            // Make visible
            if (Nodes[i].Visibility == 0)
            {
                Nodes[i].BallEffect = makeEffect(Effect.Sphere, Nodes[EvaluateOnce(i)].Color(), Nodes[EvaluateOnce(i)].ShownPosition(), NodeSize);
                Nodes[i].Visibility = 1;
            }

            // Ring effect
            if (Nodes[i].Node.Position.DistanceTo(eye) > 10)
            {
                if (Nodes[i].Visibility == 2)
                {
                    DestroyEffect(Nodes[i].RingEffect);
                    Nodes[i].Visibility = 1;
                }
            }
            else if (Nodes[i].Visibility == 1)
            {
                Nodes[i].RingEffect = makeEffect(Effect.Ring, Nodes[EvaluateOnce(i)].Color(), Nodes[EvaluateOnce(i)].Node.Position, NodeSize);
                Nodes[i].Visibility = 2;
            }
        }

        MinWait();
    }

    // Segments
    for (i = 0; Segments.Length; 1)
    {
        Number node1 = NodeIndexFromID(Segments[i].Node1);
        Number node2 = NodeIndexFromID(Segments[i].Node2);

        // Visible
        if (Nodes[node1].Visibility ||
            Nodes[node2].Visibility)
        {
            if (!Segments[i].Effect)
                Segments[i].Effect = CreateBeamEffect(
                    AllPlayers(),
                    BeamType.BrigitteFlailChainBeam,
                    EvaluateOnce(Nodes[node1].ShownPosition()),
                    EvaluateOnce(Nodes[node2].ShownPosition()),
                    Color.White,
                    EffectRev.VisibleTo
                );
        }
        // Not visible
        else if (Segments[i].Effect)
        {
            DestroyEffect(Segments[i].Effect);
            Segments[i].Effect = null;
        }

        MinWait();
    }

    Wait(0.5);
    LoopIfConditionIsTrue();
}