import 'sandbox.del';
import 'place nodes.del';
import 'utility.del';
import 'history.del';
import 'freecam.del';
import 'settings.lobby';

struct Node
{
    public Number UniqueID;
    public Vector Position;
}

struct WorldNode
{
    public Node Node;
    public Boolean Selected = false;
    public Number Visibility = 0;
    public Any BallEffect = null;
    public Any RingEffect = null;

    public Color Color(): Highlighted() ?
        (Selected ? Color.Turquoise : Color.Blue) : // selected / highlighted
        (Selected ? Color.LimeGreen : Color.White);  // unselected / highlighted
    
    public Boolean Highlighted(): SelectedNodeID == Node.UniqueID;

    public Vector ShownPosition(): Node.Position + Up() * 1.3;

    public Boolean ValidTarget(): ShownPosition().DistanceTo(ray(cameraPos, cameraPos + facing * ShownPosition().DistanceTo(cameraPos))) < NodeSize;
}

struct WorldSegment
{
    public Number ID;
    public Number Node1;
    public Number Node2;
    public Any Effect;
}

globalvar WorldNode[] Nodes = [];
globalvar WorldSegment[] Segments = [];

globalvar Number NodeUniqueID! = 1;
globalvar Number SegmentUniqueID! = 1;

Number NodeSize: 0.3;
Boolean AnyNodesSelected: Nodes.IsTrueForAny(node => node.Selected);

globalvar Number SelectedNodeIndex = -1;
globalvar Number SelectedNodeID = -1;

Number NodeIndexFromID(in Number id)
{
    for (define i = 0; Nodes.Length; 1)
        if (Nodes[i].Node.UniqueID == id)
            return i;
    
    return -1;
}

Number SegmentIndexFromID(in Number id)
{
    for (define i = 0; Segments.Length; 1)
        if (Segments[i].ID == id)
            return i;
    
    return -1;
}

void RemoveNodeByIndex(in Number index)
{
    DestroyEffect(Nodes[index].BallEffect);
    DestroyEffect(Nodes[index].RingEffect);
    Nodes.ModRemoveByIndex(index);
}

void RemoveSegmentByIndex(in Number index)
{
    DestroyEffect(Segments[index].Effect);
    Segments.ModRemoveByIndex(index);
}

rule: 'Main: Init'
{
    // Ball
    CreateEffect(
        AllPlayers().FilteredArray(p => SelectedNodeID == -1 && !host.cm_isInMenu),
        Effect.Sphere,
        Color.Orange,
        UpdateEveryFrame(watchPoint),
        0.2,
        EffectRev.VisibleToPositionRadiusAndColor);

    // Segment lines
    CreateBeamEffect(
        UpdateEveryFrame(connectingFromNode != -1 && SelectedNodeID != -1 ? AllPlayers() : null),
        BeamType.TorbjornTurretSightBeam,
        Nodes[connectingFromNode].ShownPosition(),
        Nodes[SelectedNodeIndex].ShownPosition(),
        Color.Team1,
        EffectRev.VisibleToPositionRadiusAndColor);
    CreateBeamEffect(
        UpdateEveryFrame(connectingFromNode != -1 && SelectedNodeID == -1 ? AllPlayers() : null),
        BeamType.TorbjornTurretSightBeam,
        Nodes[connectingFromNode].ShownPosition(),
        UpdateEveryFrame(watchPoint),
        Color.Team2,
        EffectRev.VisibleToPositionRadiusAndColor);
}

rule: 'Main: Selection loop'
if (Nodes.Length)
{
    // Selected node
    SelectedNodeIndex = Nodes
        .Map((node, i) => i)
        .SortedArray(i => Nodes[i].ShownPosition().DistanceTo(cameraPos))
        .FilteredArray(i => Nodes[i].ValidTarget())
        .First;
    
    SelectedNodeID = SelectedNodeIndex == -1 || !Nodes[SelectedNodeIndex].ValidTarget() ? -1 : Nodes[SelectedNodeIndex].Node.UniqueID;
    MinWait();
    LoopIfConditionIsTrue();
}

rule: 'Main: Renderer'
{
    // Nodes
    Number i;
    for (i = 0; Nodes.Length; 1)
    {
        UpdateNodeVisibility(i);
        MinWait();
    }

    // Segments
    for (i = 0; Segments.Length; 1)
    {
        UpdateSegmentVisibility(i);
        MinWait();
    }

    Wait(0.5);
    LoopIfConditionIsTrue();
}

public void UpdateNodeVisibility(Number index) 'Subroutine: Update node visibility'
{
    // Not visible.
    if (!Nodes[index].ShownPosition().IsInLineOfSight(cameraPos))
    {
        if (Nodes[index].Visibility != 0)
        {
            DestroyEffect(Nodes[index].BallEffect);
            DestroyEffect(Nodes[index].RingEffect);
            Nodes[index].Visibility = 0;
        }
    }
    else
    {
        // Make visible
        if (Nodes[index].Visibility == 0)
        {
            Nodes[index].BallEffect = makeEffect(Effect.Sphere, Nodes[EvaluateOnce(index)].Color(), Nodes[EvaluateOnce(index)].ShownPosition(), NodeSize);
            Nodes[index].Visibility = 1;
        }

        // Ring effect
        if (Nodes[index].Node.Position.DistanceTo(cameraPos) > 10)
        {
            if (Nodes[index].Visibility == 2)
            {
                DestroyEffect(Nodes[index].RingEffect);
                Nodes[index].Visibility = 1;
            }
        }
        else if (Nodes[index].Visibility == 1)
        {
            Nodes[index].RingEffect = makeEffect(Effect.Ring, Nodes[EvaluateOnce(index)].Color(), Nodes[EvaluateOnce(index)].Node.Position, NodeSize);
            Nodes[index].Visibility = 2;
        }
    }
}

public void UpdateSegmentVisibility(Number index) 'Subroutine: Update segment visibility'
{
    Number node1 = NodeIndexFromID(Segments[index].Node1);
    Number node2 = NodeIndexFromID(Segments[index].Node2);

    // Visible
    if (Nodes[node1].Visibility ||
        Nodes[node2].Visibility)
    {
        if (!Segments[index].Effect)
            Segments[index].Effect = CreateBeamEffect(
                AllPlayers(),
                BeamType.BrigitteFlailChainBeam,
                EvaluateOnce(Nodes[node1].ShownPosition()),
                EvaluateOnce(Nodes[node2].ShownPosition()),
                Color.White,
                EffectRev.VisibleTo
            );
    }
    // Not visible
    else if (Segments[index].Effect)
    {
        DestroyEffect(Segments[index].Effect);
        Segments[index].Effect = null;
    }
}