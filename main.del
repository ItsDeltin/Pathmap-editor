import 'sandbox.del';
import 'place nodes.del';
import 'utility.del';
import 'history.del';
import 'noclip.del';
import 'dummy.del';
import 'dijkstra.del';
import 'rule.del';
import 'scroll menu.del';
import 'number selector.del';
import 'pathfinder settings.del';
import 'cursor menu.del';
import 'export.del';
import 'table.del';
import 'quick menu.del';
import 'settings.lobby';

globalvar Number version = 1;

globalvar Map map = CurrentMap();

class what {} globalvar what whaat! = new what();

globalvar Number maxHistoryLength!;

rule: '┏━【◈ Paste the actions to load a previous save here!! ◈】━┓' -3
if (HasSpawned(HostPlayer()))
{
    
}

rule: 'Setup: Inspector, Performance HUD, and Settings' -1
{
    if (!WorkshopSettingToggle('Pathmap Editor', 'Enable inspector recording', false, 1))
        DisableInspectorRecording();
    CreateHudText(AllPlayers(), Text: "cap: {0} {1} {2}".Format([ServerLoad(), ServerLoadAverage(), ServerLoadPeak()]));
    maxHistoryLength = WorkshopSettingInteger("Pathmap Editor", "Undo history length", 10, 0, 100);
}

rule: 'Snapshot'
Event.OngoingPlayer
if (host == eventPlayer)
if (button(Button.Crouch))
{
    EnableInspectorRecording();
    DisableInspectorRecording();
}

rule: 'Chunk up previous save'
Event.OngoingPlayer
if (host == eventPlayer)
if (HasSpawned(host))
{
    Wait(5);
    for (Number chunker = 0; Nodes.Length; 1)
        tableAppendValue(host.chunks, chunkFromPosition(Nodes[chunker].Node.Position), Nodes[chunker].Node.UniqueID);
}

struct Node
{
    public Number UniqueID;
    public Vector Position;
    public Number[] Neighbors = [];
}

struct WorldNode
{
    public Node Node;
    public Boolean Selected = false;
    public Number Visibility = 0;
    public Any BallEffect = null;
    public Any RingEffect = null;

    public Color Color(): Highlighted() ?
        (Selected ? Color.Turquoise : Color.Blue) : // selected / highlighted
        (Selected ? Color.LimeGreen : Color.White);  // unselected / highlighted
    
    public Boolean Highlighted(): SelectedNodeID == Node.UniqueID;

    public Vector ShownPosition(): Node.Position + Up() * 1.3;

    public Boolean ValidTarget(): ShownPosition().DistanceTo(eye + facing * ShownPosition().DistanceTo(eye)) < NodeSize;
}

struct Attribute
{
    public Number Value;
    public Number ID;
    public Number Node1;
    public Number Node2;
}

globalvar WorldNode[] Nodes = [];
globalvar Attribute[] Attributes = [];

globalvar Number NodeUniqueID! = 1;
globalvar Number AttributeUniqueID! = 1;

Number NodeSize: 0.3;
Boolean AnyNodesSelected: Nodes.IsTrueForAny(node => node.Selected);

globalvar Number SelectedNodeIndex! = -1;
globalvar Number SelectedNodeID! = -1;
globalvar Number SelectedSegmentID! = -1;
globalvar Player SelectedPlayer!;
globalvar Any[] AttributeTexts = [];

globalvar Vector mapOffset!;
globalvar Vector mapRange!;
// The number of rows in the chunk's data x dimension
globalvar Number chunkRow! = 30;
// The chunk size
Number chunkSize: 20;

playervar Table<Number, Number[]> chunks = Table<Number, Number[]>.newTable();
// The ID of the chunk the player is currently standing in.
playervar Number currentChunk;
// The list of loaded chunks.
playervar Number[] loadedChunks;
// The list of loaded nodes.
playervar Number[] loadedNodes = [];
// The list of loaded segments.
playervar Table<Number, Any> loadedSegments = Table<Number, Any>.newTable();

Number chunkFromPosition(in Vector pos)
{
    return((pos.X - mapOffset.X) / chunkSize).Floor() * chunkRow
        + ((pos.Z - mapOffset.Z) / chunkSize).Floor();
}

Number NodeIndexFromID(in Number id): Nodes.Map(node => node.Node.UniqueID).IndexOf(id);
Number NodeIDFromIndex(in Number index): Nodes[index].Node.UniqueID;
Number AttributeIndexFromID(in Number id): Attributes.Map(attribute => attribute.ID).IndexOf(id);

Number unorderedCantor(in Number a, in Number b): (1/2)*(Min(a, b) + Max(a, b)) * (Min(a, b) + Max(a, b) + 1) + Max(a, b);

void RemoveNodeByIndex(Number index) 'Subroutine: Remove node'
{
    DestroyEffect(Nodes[index].BallEffect);
    DestroyEffect(Nodes[index].RingEffect);
    Nodes.ModRemoveByIndex(index);
}

void RemoveAttributeByIndex(Number index) 'Subroutine: Remove attribute'
{
    Attributes.ModRemoveByIndex(index);
}

rule: 'Player init'
Event.OngoingPlayer
if (!IsDummyBot())
{
    DisallowButton(eventPlayer, Button.PrimaryFire);
    DisallowButton(eventPlayer, Button.SecondaryFire);
    DisallowButton(eventPlayer, Button.Ultimate);
    DisallowButton(eventPlayer, Button.Ability1);
}

rule: 'Calculate map bounds'
if (HasSpawned(host))
{
    Number buffer: 1.2;
    Number maxSize: 1000;
    Vector sw! = NearestWalkablePosition(Vector(-maxSize, 0, -maxSize)) * buffer;
    Vector nw! = NearestWalkablePosition(Vector(-maxSize, 0, maxSize)) * buffer;
    Vector se! = NearestWalkablePosition(Vector(maxSize, 0, -maxSize)) * buffer;
    Vector ne! = NearestWalkablePosition(Vector(maxSize, 0, maxSize)) * buffer;
    mapOffset = Vector(Min(sw.X, nw.X), 0, Min(sw.Z, se.Z));
    mapRange = Vector(Max(se.X, ne.X), 0, Max(nw.Z, ne.Z)) - mapOffset;
    chunkRow = (Max(mapRange.X, mapRange.Z) / chunkSize).Ceil();

    CreateHudText(AllPlayers(), 'chunk: ' + chunkFromPosition(PositionOf(host)) + ' position: ' + PositionOf(host));
}

rule: 'Entered new chunk'
Event.OngoingPlayer
if (host == eventPlayer)
if (currentChunk != chunkFromPosition(PositionOf()))
{
    Number chunk = chunkFromPosition(PositionOf());
    Number[] loadChunks = [
        chunk - chunkRow - 1, chunk - chunkRow, chunk - chunkRow + 1,
        chunk - 1, chunk, chunk + 1,
        chunk + chunkRow - 1, chunk + chunkRow, chunkRow + chunkRow + 1];
    
    Number[] unloadChunks = loadedChunks.FilteredArray(c => !loadChunks.Contains(c));

    // Unload previous chunk.
    Number li; Number ri; Number nIndex; Number nID;

    iterateChunks(li, ri, nIndex, nID, unloadChunks, () => {
        destroyNodeEffect(nIndex);
        loadedNodes -= nID;
    }, (nID1, nID2, cantor) => {
        // Remove from loaded segments.
        Number remove = loadedSegments.indexOfKey(cantor);
        if (remove != -1 && !loadedNodes.Contains(nID1) && !loadedNodes.Contains(nID2))
        {
            DestroyEffect(loadedSegments.Values[remove]);
            tableRemoveIndex(loadedSegments, remove);
        }
    });
    iterateChunks(li, ri, nIndex, nID, loadChunks, () => {
        makeNodeEffect(nIndex);
    }, (nID1, nID2, cantor) => {
        makeSegmentEffect(cantor, nID1, nID2);
    });

    currentChunk = chunk;
    loadedChunks = loadChunks;
    Wait(0.25);
    LoopIfConditionIsTrue();
}

void iterateChunks(ref Number li, ref Number ri, ref Number nIndex, ref Number nID, in Number[] chunkIndexes,
    const () => void exec,
    const (Number, Number, Number) => void execNeighbor)
{
    for (li = 0; chunkIndexes.Length; 1) {
        if (chunks.keyExists(chunkIndexes[li]))
        for (ri = 0; chunks.get(chunkIndexes[li]).Length; 1) {
            nID = chunks.get(chunkIndexes[li])[ri];
            nIndex = NodeIndexFromID(nID);
            exec();
            
            // Neighbor action
            foreach (Number neighbor in Nodes[nIndex].Node.Neighbors) {
                Number cantor = unorderedCantor(nID, neighbor);
                execNeighbor(nID, neighbor, cantor);
            }
        }
        MinWait();
    }
}

void makeNodeEffect(in Number nIndex)
{
    if (!Nodes[nIndex].Visibility) {
        Nodes[nIndex].BallEffect = makeEffect(Effect.Sphere, Nodes[EvaluateOnce(nIndex)].Color(), Nodes[EvaluateOnce(nIndex)].ShownPosition(), NodeSize);
        Nodes[nIndex].Visibility = 1;
        host.loadedNodes += NodeIDFromIndex(nIndex);
    }
}

void destroyNodeEffect(in Number nIndex)
{
    if (Nodes[nIndex].Visibility) {
        DestroyEffect(Nodes[nIndex].BallEffect);
        DestroyEffect(Nodes[nIndex].RingEffect);
        Nodes[nIndex].Visibility = 0;
    }
}

void tryMakeNode(in Number chunkIndex, in Number nIndex)
{
    if (host.loadedChunks.Contains(chunkIndex) && !Nodes[nIndex].Visibility) {
        // todo: visiblity is check twice
        makeNodeEffect(nIndex);
    }
}

void showSegment(Vector segment) 'Subroutine: make segment'
{
    Number nID1: segment.X;
    Number nID2: segment.Y;

    Boolean isAtLeastOneNodeLoaded = host.loadedNodes.Contains(nID1) || host.loadedNodes.Contains(nID2);
    Number cantor = unorderedCantor(nID1, nID2);

    if (isAtLeastOneNodeLoaded)
        makeSegmentEffect(cantor, nID1, nID2);
}

void destroySegment(Vector segment) 'Subroutine: destroy segment'
{
    Number nID1: segment.X;
    Number nID2: segment.Y;
    Number cantor = unorderedCantor(nID1, nID2);

    host.loadedSegments.ifKey(cantor, (effect, index) => {
        DestroyEffect(effect);
        tableRemoveIndex(host.loadedSegments, index);
    });
}

void makeSegmentEffect(in Number cantor, in Number nID1, in Number nID2)
{
    if (!host.loadedSegments.keyExists(cantor))
        tableAdd(host.loadedSegments, cantor, CreateBeamEffect(
            UpdateEveryFrame(editorState != EditorState.Node || attributeMode
                || Min(SelectedSegmentID, NodeIDFromIndex(ConnectingFromNodeIndex)) != EvaluateOnce(Min(nID1, nID2))
                || Max(SelectedSegmentID, NodeIDFromIndex(ConnectingFromNodeIndex)) != EvaluateOnce(Max(nID1, nID2))
                || TotalTimeElapsed() % 1 < 0.5 ? AllPlayers() : null),
            BeamType.BrigitteFlailChainBeam,
            Nodes[EvaluateOnce(NodeIndexFromID(nID1))].ShownPosition(),
            Nodes[EvaluateOnce(NodeIndexFromID(nID2))].ShownPosition(),
            Color.White,
            EffectRev.VisibleTo
        ));
}

globalvar Vector positionDirection;

rule: 'Main: Selection loop'
if (!host.cm_isInMenu)
if (Nodes.Length || AllPlayers().IsTrueForAny(player => player.IsDummy()))
if (positionDirection != host.FacingDirection() + host.Position())
{
    positionDirection = host.FacingDirection() + host.Position();
    // Find player
    AllPlayers().dummyHighlighted = false;
    SelectedPlayer = RayCastHitPlayer(eye, eye + facing * 100, AllPlayers(), host, false);
    SelectedPlayer.dummyHighlighted = true;

    // Selected node
    Number[] tempNode! = Nodes
        .Map((node, i) => i)
        .SortedArray(i => Nodes[i].ShownPosition().DistanceTo(eye))
        .FilteredArray(i => Nodes[i].ValidTarget());
    
    SelectedNodeIndex = tempNode.Length ? tempNode.First : -1;
    
    // Player and node found, choose one.
    if (SelectedPlayer != null && SelectedNodeIndex != -1)
    {
        if (Nodes[SelectedNodeIndex].ShownPosition().DistanceTo(eye) > SelectedPlayer.Position().DistanceTo(eye))
            SelectedNodeIndex = -1;
        else
            SelectedPlayer = null;
    }
    
    Number previouslySelectedNodeID = SelectedNodeID;
    
    if (SelectedNodeIndex == -1)
        SelectedNodeID = -1;
    else
        SelectedNodeID = Nodes[SelectedNodeIndex].Node.UniqueID;

    if (previouslySelectedNodeID != SelectedNodeID)
    {
        UpdateAttributeVisibility();

        // Get segment that contains both nodes.
        if (ConnectingFromNodeIndex == -1 || SelectedNodeID == -1)
            SelectedSegmentID = -1;
        else
        {
            Number[] tempSegment! = Nodes[ConnectingFromNodeIndex].Node.Neighbors.FilteredArray(n => n == SelectedNodeID);            
            SelectedSegmentID = tempSegment == [] ? -1 : tempSegment.First;
        }
    }

    Wait(0.1);
    LoopIfConditionIsTrue();
}

public void UpdateAttributeVisibility() 'Subroutine: Update attribute visibility'
{
    while (AttributeTexts.Length)
    {
        DestroyInWorldText(AttributeTexts.First);
        AttributeTexts.ModRemoveByIndex(0);
    }

    // Show connected attributes.
    Number useNode! =
        SelectedNodeID != -1 ? SelectedNodeID :
        ConnectingFromNodeIndex != -1 ? Nodes[ConnectingFromNodeIndex].Node.UniqueID : -1;

    if (useNode == -1)
    {
        return;
    }

    define attributeIndices = Attributes.Map((s, i) => i).FilteredArray(
        i => Attributes[i].Node1 == useNode || Attributes[i].Node2 == useNode
    );
    
    while (attributeIndices.Length)
    {
        Vector p1 = Nodes[NodeIndexFromID(Attributes[attributeIndices.First].Node1)].ShownPosition();
        Vector p2 = Nodes[NodeIndexFromID(Attributes[attributeIndices.First].Node2)].ShownPosition();
        Boolean isSource = Attributes[attributeIndices.First].Node1 == useNode;

        define group = attributeIndices.FilteredArray(i =>
            Attributes[attributeIndices.First].Node1 == Attributes[i].Node1 &&
            Attributes[attributeIndices.First].Node2 == Attributes[i].Node2
        );

        // Remove from attributeIndices the values in the current group.
        attributeIndices -= group;

        // Generate string
        String string! = '';
        while (group.Length)
        {
            string = <' <0>\n<2><1><2>', string, Attributes[group.First].Value, isSource ? '◈' : ''>;
            group.ModRemoveByIndex(0);
        }

        AttributeTexts += CreateInWorldText(
            VisibleTo: AllPlayers(),
            Header: string,
            Position: p1 + (p2 - p1) * 0.3,
            Scale: 2.5,
            Clipping: Clipping.DoNotClip,
            Reevaluation: InworldTextRev.VisibleTo,
            TextColor: isSource ? Color.SkyBlue : CustomColor(255, 115, 0, 100)
        );
    }
}

playervar Boolean releasePrimary;

rule: 'Release primary'
Event.OngoingPlayer
if (releasePrimary)
if (!IsButtonHeld(EventPlayer(), Button.PrimaryFire))
{
    releasePrimary = !releasePrimary;
}