import 'main.del';

struct MirrorMeta
{
    public Map Map;
    public Number A;
    public Number B;
    public Boolean X;
}

MirrorMeta m_x(Map map, Number x): {
    Map: map,
    X: true,
    A: x,
    B: 0,
};
MirrorMeta m_ab(Map map, Number a, Number b): {
    Map: map,
    X: false,
    A: a,
    B: b
};
MirrorMeta m_p(Map map): m_x(map, 0);

// Provided by Zezombye
// https://github.com/Zezombye/overpy/blob/master/src/data/maps.js
MirrorMeta[] mirrorMeta: [
    m_ab(Map.Ayutthaya, 0, -7),
    m_ab(Map.Black_Forest, 0, 5),
    m_ab(Map.Black_Forest_Winter, 0, 5),
    m_x(Map.Busan_Downtown_Lunar, 51.9),
    m_x(Map.Busan_Sanctuary_Lunar, 51.9),
    m_ab(Map.Castillo, -0.19009, 38.79879),
    m_ab(Map.Ecopoint_Antarctica, 0, 0),
    m_ab(Map.Ecopoint_Antarctica_Winter, 0, 0),
    m_ab(Map.Ilios_Lighthouse, -0.41437, 96.86593),
    m_x(Map.Ilios_Ruins, 28.6),
    m_ab(Map.Ilios_Well, 1.00409, 192.85907),
    m_x(Map.Lijiang_Control_Center, 0),
    m_x(Map.Lijiang_Control_Center_Lunar, 0),
    m_x(Map.Lijiang_Garden, 0),
    m_x(Map.Lijiang_Garden_Lunar, 0),
    m_x(Map.Lijiang_Night_Market, 0),
    m_x(Map.Lijiang_Night_Market_Lunar, 0),
    m_ab(Map.Necropolis, 0, 0),
    m_ab(Map.Nepal_Sanctum, 0, 0),
    m_ab(Map.Nepal_Shrine, 0, 0),
    m_ab(Map.Nepal_Village, 0, 0),
    m_ab(Map.Oasis_City_Center, 1.00002, 103.99783),
    m_ab(Map.Oasis_Gardens, -1.00042, -106.1637),
    m_ab(Map.Oasis_University, 0, 0),
    m_ab(Map.Workshop_Chamber, 0, 0),
    m_ab(Map.Workshop_Expanse, 0, 0),
    m_ab(Map.Workshop_Expanse_Night, 0, 0),
    m_ab(Map.Workshop_Island, 0, 0),
    m_ab(Map.Workshop_Island_Night, 0, 0)
];
// Push maps are flipped on the X axis

// Show mirror preview
rule: 'Mirror'
Event.OngoingPlayer
if (IsButtonHeld(host, Button.Melee))
{
    Number mirrorNodesBegin = Nodes.Length;
    Number mirrorSegmentsBegin = Segments.Length;
    Number mirrorAttributesBegin = Attributes.Length;

    // Get map mirror data.
    Number mapId = mirrorMeta.Map(m => m.Map).IndexOf(CurrentMap());
    Number a = 0;
    Number b = 0;
    Boolean p = true;
    if (mapId != -1)
    {
        a = mirrorMeta[mapId].A;
        b = mirrorMeta[mapId].B;
        p = mirrorMeta[mapId].X;
    }

    # The distance where a mirrored node will be ignored.
    Number mergeRadius: 2;
    # The index of a node's mirrored node can be obtained by doing
    # `nodeMirrors[nodeIndex]`
    Number[] nodeMirrors = [];

    // Mirror nodes
    for (Number i! = 0; mirrorNodesBegin; 1) {
        // Do not mirror if the node is selected.
        // if (Nodes[i].Selected) {
        //     continue;
        // }

        // Get the mirrored node position.
        Vector pos;
        if (p)
            pos = Nodes[i].Node.Position * Vector(-1 , 1, 1) + Vector(a, 0, 0);
        else
            pos = mirror(Nodes[i].Node.Position, a, b);

        // Do not mirror if the mirrored node is too close.
        if (pos.DistanceTo(Nodes[i].Node.Position) < mergeRadius) {
            nodeMirrors[i] = i;
            MinWait();
            continue;
        }

        // Find existing nodes in the mirrored position.
        Vector[] inRadius = Nodes.Map(n => n.Node.Position).FilteredArray(n => n.DistanceTo(pos) < mergeRadius);
        // Do not mirror if a node already exists.
        if (inRadius.Length)
        {
            nodeMirrors[i] = Nodes.Map(n => n.Node.Position).IndexOf(inRadius.First);
            MinWait();
            continue;
        }

        nodeMirrors[i] = Nodes.Length;

        NodeUniqueID++;
        Nodes += { Node: {Position: pos, UniqueID: NodeUniqueID}, Selected: true };
        MinWait();
    }
    # Mirror segments
    mirrorNodeConnectedArray(nodeMirrors, Segments, mirrorSegmentsBegin, SegmentUniqueID,
        seg => seg.Node1,
        seg => seg.Node2,
        (o, id, n1, n2) => { Node1: n1, Node2: n2, ID: id }
    );
    # Mirror attributes
    mirrorNodeConnectedArray(nodeMirrors, Attributes, mirrorAttributesBegin, AttributeUniqueID,
        attr => attr.Node1,
        attr => attr.Node2,
        (o, id, n1, n2) => { Value: o.Value, ID: id, Node1: n1, Node2: n2 }
    );
    # Update visiblity
    updateRenderingNodes();
}

void mirrorNodeConnectedArray<T>(
    in Number[] nodeMirrors,
    ref T[] array,
    in Number arrayLength,
    ref Number uniqueId,
    const T => Number getNode1,
    const T => Number getNode2,
    const (T, Number, Number, Number) => T mirroredValue)
{
    // Segments
    for (Number i = 0; arrayLength; 1) {
        Number node1Index = NodeIndexFromID(getNode1(array[i]));
        Number node2Index = NodeIndexFromID(getNode2(array[i]));

        // The mirrored segment would be the same as the current segment.
        // This will occur if 2 nodes on the center line of the map are connected to each other.
        if ((nodeMirrors[node1Index] == node1Index && nodeMirrors[node2Index] == node2Index)) {
            MinWait();
            continue;
        }

        /*
        array.IsTrueForAny(v =>
            (getNode1(v) == getNode1(array[i]) && getNode2(v) == getNode2(array[i])) ||
            (getNode1(v) == getNode2(array[i]) && getNode2(v) == getNode1(array[i])))
        */

        uniqueId++;
        array += mirroredValue(
            array[i],
            uniqueId,
            Nodes[nodeMirrors[node1Index]].Node.UniqueID,
            Nodes[nodeMirrors[node2Index]].Node.UniqueID
        );

        MinWait();
    }
}

Vector mirror(in Vector v, in Number a, in Number b)
{
    // todo: one of these normalizes can probably go
    Vector n = Vector(a, 0, -1).Normalize().CrossProduct(Up()).Normalize();
    Vector p = Vector(-b/a, 0, 0);
    Vector w = v - p;
    Number t = DotProduct(w, n);
    Vector r = p + t * n;

    return v + (r - v * Vector(1, 0, 1)) * 2;
}