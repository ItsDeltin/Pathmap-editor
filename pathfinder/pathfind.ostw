struct PfMap {
    # The points in the map.
    public Vector[] nodes;
    # `[node][i][0]` = neighbor index,
    # `[node][i][1][j]` = attributes
    public Any[][][] neighbors;
}

struct PfNode {
    public Number gScore;
    public Number fScore;
    public Number parent;
}

# The currently loaded map
globalvar PfMap pfLoadedMap;
globalvar Number[][] pfTableTemplate;
globalvar Number pfIterationsThisTick;

# The final pathfinding target.
playervar Vector pfDestination;
# The attributes assigned to the player.
playervar Number[] pfPlayerAttributes;
# The attributes of a player's current pathfinding edge.
playervar Number[] pfAttributes;

# The saved target. If the distance between this and pfDestination becomes
# too large, the pathfinding path will be updated.
playervar Vector pfSavedTarget;
# Determines if the player is pathfinding.
playervar Boolean pfIsPathfinding;
# The current node that the player is walking to.
# If this is -1 but `pfIsPathfinding` is true, then the player
# is walking to `pfDestination`.
playervar Number pfCurrentNodeIndex;
# The position that the player is actively walking towards.
playervar Vector pfWalkingToPosition;
# The nextNode array for pathfinding.
playervar Number[] pfPath;
playervar Number pfStartTime;
playervar Number pfDistanceToNextNode;
playervar Vector pfLastNodeStartingPosition;
playervar Vector pfNextPosition;
playervar Boolean pfIsPartialPath;

playervar Number pfStartingNode;
playervar Number[] pfOpen;
playervar Number[] pfCameFrom;
playervar Number[] pfGScore;
playervar Number[] pfFScore;

rule: '【PF Core】what'
if (IsJumping(HostPlayer()))
{
    SmallMessage(AllPlayers(), 'Amazing hop, my liege!');
}

rule: '【PF Core】Init loaded map'
if (pfLoadedMap.nodes)
{
    pfTableTemplate = [pfLoadedMap.nodes.Map(n => -1), pfLoadedMap.nodes.Map(n => 9999)];
}

rule: '【PF Core】Setup Event Player'
Event.OngoingPlayer
{
    pfStartingNode = -1;
    pfOpen = [];
    pfCameFrom = [];
    pfGScore = [];
    pfFScore = [];
}

rule: '【PF Core】Next Tick'
if (pfIterationsThisTick)
{
    pfIterationsThisTick = Max(0, pfIterationsThisTick - 10);
    MinWait();
    LoopIfConditionIsTrue();
}

void pfTick() '【PF Core Subroutine】☞ Tick'
{        
    while (pfIterationsThisTick >= 10) {
        MinWait();
        WaitUntil(pfIterationsThisTick < 10, 9999);
    }
    pfIterationsThisTick++;
}

rule: '【PF Core】Update & Execute'
Event.OngoingPlayer
if (pfDestination)
if (EventPlayer().DistanceTo(pfDestination) > 4)
if (!pfSavedTarget || pfDestination.DistanceTo(pfSavedTarget) > 5)
{
    # Debug Message
    SmallMessage(AllPlayers(), <'Updated pathfinder for <0>', EventPlayer()>);
    # Stop throttle while loading next paths
    StopThrottleInDirection(EventPlayer());
    # Update saved destination
    pfSavedTarget = pfDestination;
    # If the bot's starting node was not set, update it.
    // if (pfStartingNode == -1) {
    pfTick();
    pfStartingNode = chooseNodeFromPosition(PositionOf());
    # Reset cameFrom, gScore, and open values.
    pfCameFrom = pfTableTemplate[0];
    pfGScore = pfTableTemplate[1];
    pfFScore = pfTableTemplate[1];
    pfGScore[pfStartingNode] = 0;
    pfFScore[pfStartingNode] = 0;
    pfOpen = [pfStartingNode];
    // } else {
    //     # Update the bot's starting node.
    //     pfGScore[pfStartingNode] = 0;
    //     pfFScore[pfStartingNode] = 0;
    //     pfCameFrom[pfStartingNode] = -1;
    //     pfOpen += pfStartingNode;
    // }
    # Update goal position
    Number goal = chooseNodeFromPosition(pfDestination);
    aStar(goal, pfPlayerAttributes, pfPath);
    pfIsPathfinding = true;
    pfCurrentNodeIndex = pfPath.Last;
    pfWalkingToPosition = pfLoadedMap.nodes[pfCurrentNodeIndex];
    UpdateNodeMeta();
    StartThrottleInDirection(EventPlayer(), PositionOf().DirectionTowards(pfWalkingToPosition), 1, Relative.ToWorld, ThrottleBehavior.ReplaceExistingThrottle, ThrottleRev.DirectionAndMagnitude);
    Wait(2);
    LoopIfConditionIsTrue();
}

rule: '【PF Core】Node reached'
Event.OngoingPlayer
if (pfIsPathfinding)
if (EventPlayer().DistanceTo(pfWalkingToPosition) <= 0.4) {
    # The player reached the next node in the path to the destination.
    if (pfCurrentNodeIndex == -1) {
        # The destination was reached, stop pathfinding.
        StopThrottleInDirection(EventPlayer());
        pfIsPathfinding = false;
    } else {
        ProgressEventPlayer();
    }
    Wait(0.2);
    LoopIfConditionIsTrue();
}

disabled rule: '【PF Core】(optional) Skip node when shortcut is found'
Event.OngoingPlayer
if (pfIsPathfinding)
if (pfCurrentNodeIndex != -1)
if (IsInLineOfSight(PositionOf() + Up() * 0.25, pfNextPosition + Up() * 0.25))
if ((PositionOf().Y - pfNextPosition.Y).Abs() < 1)
{
    SmallMessage(AllPlayers(), 'Compatible node skip found');
    Wait(0.1);
    ProgressEventPlayer();
    Wait(0.1);
    LoopIfConditionIsTrue();
}

disabled rule: '【PF Core】(optional) Teleport player to next node when player gets stuck.'
Event.OngoingPlayer
if (pfIsPathfinding)
if (pfDistanceToNextNode - 5.5 * 0.5 * (TotalTimeElapsed() - pfStartTime) < 0)
{
    SmallMessage(AllPlayers(), <'Player <0> got stuck, teleporting them.', EventPlayer()>);
    Teleport(EventPlayer(), pfWalkingToPosition);
    Wait(3);
    LoopIfConditionIsTrue();
}

void ProgressEventPlayer() playervar '【PF Core Subroutine】☞ Progress event player' {
    # Update the current pathfind attributes.
    # Any rules watching these with the matching condition will activate.
    pfAttributes = pfLoadedMap.neighbors[pfCurrentNodeIndex].FilteredArray(segment => segment[0] == pfPath.Last).First.Last;
    # The next aStart's current node will start on the node that was just reached.
    pfStartingNode = pfCurrentNodeIndex;
    # Go to the next node in the path.
    pfCurrentNodeIndex = pfPath.Last;
    # Pop the current path.
    pfPath.ModRemoveByIndex(pfPath.Length - 1);
    # Set the position that the player is currently walking towards.
    pfWalkingToPosition = pfCurrentNodeIndex == -1 ? pfDestination : pfLoadedMap.nodes[pfCurrentNodeIndex];
    UpdateNodeMeta();
}

void UpdateNodeMeta() playervar '【PF Core Subroutine】☞ Update node meta' {
    # Update the pathfinding start time.
    pfStartTime = TotalTimeElapsed();
    pfDistanceToNextNode = EventPlayer().DistanceTo(pfWalkingToPosition);
    pfLastNodeStartingPosition = EventPlayer().Position();
    pfNextPosition = pfPath.Length >= 2 ? pfDestination : pfLoadedMap.nodes[pfPath[pfPath.Length - 2]];
}

# Selects a node index from a position.
Number chooseNodeFromPosition(in Vector vector) {
    return pfLoadedMap.nodes.IndexOf(pfLoadedMap.nodes
        .SortedArray(n => n.DistanceTo(vector))
        .Slice(0, 5)
        .SortedArray(n => !(IsInLineOfSight(n + Up() * 2, vector + Up() * 2) && (vector.Y - n.Y).Abs() < vector.DistanceTo(n) / 2))
        .First);
}

# Gets the shortest path from start to goal.
# - `map`: The input map.
# - `start`: Index of the starting node.
# - `goal`: Index of the goal node.
# - `pathArray`: The results are appended to this map.
void aStar(in Number goal, in Number[] attributes, ref Number[] pathArray) {
    Number heuristicWeight: 20;
    const Number => Number h: n => (pfLoadedMap.nodes[n]).DistanceTo(pfLoadedMap.nodes[goal]) * heuristicWeight;

    // PfNode[] scores = [{ parent: -1, gScore: 0, fScore: 0 }];
    // Number[] map = [pfStartingNode];

    Number iter = 0;
    while (pfOpen.Length) {
        // Debug
        // Any[] icons = [];
        // foreach (Number o in pfOpen) {
        //     icons += CreateInWorldText(AllPlayers(), o, pfLoadedMap.nodes[o], 2, Clipping.DoNotClip, InworldTextRev.VisibleTo, Color.White);
        // }
        // WaitForClick();
        // foreach (Any icon in icons) {
        //     DestroyInWorldText(icon);
        // }

        Number current = pfOpen.SortedArray((o, i) => pfFScore[o]).First;
        # If the goal was found, reconstruct the path.
        if (current == goal) {
            // pfIsPartialPath = iter == 20;
            reconstructPath(pfCameFrom, current, pathArray);
            return;
        }

        // Any[] neighborIcons = [CreateInWorldText(AllPlayers(), current, pfLoadedMap.nodes[current], 2, Clipping.DoNotClip, InworldTextRev.VisibleTo, Color.Rose)];
        pfOpen.ModRemoveByValue(current);

        # Check each neighbor to the current node.
        foreach (Any[] neighbor in pfLoadedMap.neighbors[current]) {
            // Color neighborColor = Color.Red;
            # Ensure that the path to the neighbor is enabled.
            if ((<Number[]>neighbor[1]).IsTrueForAll(a => attributes.Contains(a))) {
                Number neighborI = neighbor[0];
                Number score = pfGScore[current] + pfLoadedMap.nodes[current].DistanceTo(pfLoadedMap.nodes[neighborI]);

                // neighborColor = Color.Blue;
                if (score < pfGScore[neighborI]) {
                    pfCameFrom[neighborI] = current;
                    pfGScore[neighborI] = score;
                    pfFScore[neighborI] = score + h(neighborI);
                    if (!pfOpen.Contains(neighborI))
                        pfOpen += neighborI;
                    // neighborColor = Color.Green;
                }

            }
            pfTick();
            // neighborIcons += CreateInWorldText(AllPlayers(), neighbor[0], pfLoadedMap.nodes[neighbor[0]], 2, Clipping.DoNotClip, InworldTextRev.VisibleTo, neighborColor);
        }

        // WaitForClick();
        // foreach (Any icon in neighborIcons) {
            // DestroyInWorldText(icon);
        // }
        iter++;
    }
}

void reconstructPath(in Number[] cameFrom, ref Number current, ref Number[] pathArray) {
    pathArray = [-1];
    while (current != -1) {
        pathArray += current;
        current = cameFrom[current];
        pfTick();

        // if (current != -1)
        //     CreateBeamEffect(AllPlayers(), BeamType.GoodBeam, pfLoadedMap.nodes[pathArray.Last], pfLoadedMap.nodes[current], Color.Rose, EffectRev.VisibleTo);
    }

    // WaitForClick();
    // DestroyAllEffects();
}

void WaitForClick()
{
    WaitUntil(!IsButtonHeld(HostPlayer(), Button.PrimaryFire), 0.2);
    WaitUntil(IsButtonHeld(HostPlayer(), Button.PrimaryFire), 9999);
}