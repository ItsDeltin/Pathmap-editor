struct PfMap {
    # The points in the map.
    public Vector[] nodes;
    # `[node][i][0]` = neighbor index,
    # `[node][i][1][j]` = attributes
    public Any[][][] neighbors;
}

# The currently loaded map
globalvar PfMap pfLoadedmap;
# The final pathfinding target.
playervar Vector pfDestination;
# Determines if the player is pathfinding.
playervar Boolean pfIsPathfinding;
# The current node that the player is walking to.
# If this is -1 but `pfIsPathfinding` is true, then the player
# is walking to `pfDestination`.
playervar Number pfCurrentNodeIndex;
# The position that the player is actively walking towards.
playervar Vector pfWalkingToPosition;
# The attributes of a player's current pathfinding edge.
playervar Number[] pfAttributes;
# The nextNode array for pathfinding.
playervar Number[] pfPath;

rule: 'Pathfinder: Node reached'
Event.OngoingPlayer
if (pfIsPathfinding)
if (EventPlayer().DistanceTo(pfWalkingToPosition) <= 0.4) {
    # The player reached the next node in the path to the destination.
    # If pfCurrentNodeIndex is -1 then pfWalkingToPosition is the destination.
    if (pfCurrentNodeIndex == -1) {
        # The destination was reached, stop pathfinding.
        StopThrottleInDirection(EventPlayer());
        pfIsPathfinding = false;
    } else {
        # Update the current pathfind attributes.
        # Any rules watching these with the matching condition will activate.
        pfAttributes = pfLoadedmap.neighbors[pfCurrentNodeIndex].FilteredArray(segment => segment[0] == pfPath.Last).First.Last;
        # Go to the next node in the path.
        pfCurrentNodeIndex = pfPath.Last;
        # Pop the current path.
        pfPath.ModRemoveByIndex(pfPath.Length - 1);
        # Set the position that the player is currently walking towards.
        pfWalkingToPosition = pfCurrentNodeIndex == -1 ? pfDestination : pfLoadedmap.nodes[pfCurrentNodeIndex];
    }
    Wait(0.2);
    LoopIfConditionIsTrue();
}

# Selects a node index from a position.
Number chooseNodeFromPosition(in Vector vector) {
    return pfLoadedmap.nodes.IndexOf(pfLoadedmap.nodes
        .SortedArray(n => n.DistanceTo(vector))
        .Slice(0, 5)
        .SortedArray(n => !IsInLineOfSight(n + Up() * 2, vector + Up() * 2))
        .First);
}

void pathfindPlayer(Player player, Vector destination, Number[] attributes) globalvar 'Subroutine: Pathfind Player' {
    Number start = chooseNodeFromPosition(player.Position());
    Number goal = chooseNodeFromPosition(destination);
    aStar(pfLoadedmap, start, goal, attributes, player.pfPath);
    player.pfDestination = destination;
    player.pfIsPathfinding = true;
    player.pfCurrentNodeIndex = player.pfPath.Last;
    player.pfWalkingToPosition = pfLoadedmap.nodes[pfCurrentNodeIndex];
    StartThrottleInDirection(EventPlayer(), PositionOf().DirectionTowards(player.pfWalkingToPosition), 1, Relative.ToWorld, ThrottleBehavior.ReplaceExistingThrottle, ThrottleRev.DirectionAndMagnitude);
}

# Gets the shortest path from start to goal.
# - `map`: The input map.
# - `start`: Index of the starting node.
# - `goal`: Index of the goal node.
# - `pathArray`: The results are appended to this map.
void aStar(in PfMap map, in Number start, in Number goal, in Number[] attributes, ref Number[] pathArray) {
    Number heuristicWeight: 2;
    const Number => Number h: n => map.nodes[n].DistanceTo(map.nodes[goal]) * heuristicWeight;

    Number[] open = [start];
    Number[] cameFrom = map.nodes.Map(n => -1);
    Number[] gScore = map.nodes.Map(n => 9999);
    gScore[start] = 0;
    Number iter = 0;

    while (open.Length) {
        Number current = open.SortedArray((o, i) => gScore[o] + h(o)).First;
        # If the goal was found, reconstruct the path.
        if (current == goal) {
            SmallMessage(AllPlayers(), <'Completed in <0> iterations', iter>);
            reconstructPath(cameFrom, current, pathArray);
            return;
        }
        
        open.ModRemoveByValue(current);

        foreach (Any[] neighbor in map.neighbors[current]) {
            if ((<Number[]>neighbor[1]).IsTrueForAll(a => attributes.Contains(a))) {
                Number neighborI = neighbor[0];
                Number score = gScore[current] + map.nodes[current].DistanceTo(map.nodes[neighborI]);
                if (score < gScore[neighborI]) {
                    cameFrom[neighborI] = current;
                    gScore[neighborI] = score;
                    if (!open.Contains(neighborI))
                        open += neighborI;
                }
            }
        }
        iter++;
    }
}

void reconstructPath(in Number[] cameFrom, ref Number current, ref Number[] pathArray) {
    pathArray = [-1];
    while (current != -1) {
        pathArray += current;
        current = cameFrom[current];
    }
}