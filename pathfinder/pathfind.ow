variables
{
    global:
        0: pfLoadedmap_nodes
        1: pfLoadedmap_neighbors
        2: player
        3: destination
        4: attributes
        5: start
        6: goal
        7: open
        8: cameFrom
        9: gScore
        10: iter
        11: current
        12: neighbor
        13: neighborI
        14: score
    player:
        0: pfDestination
        1: pfIsPathfinding
        2: pfCurrentNodeIndex
        3: pfWalkingToPosition
        4: pfAttributes
        5: pfPath
}

subroutines
{
    0: pathfindPlayer
}

rule("Pathfinder: Node reached")
{

    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Event Player.pfIsPathfinding == True;
        Distance Between(Event Player, Event Player.pfWalkingToPosition) <= 0.4;
    }

    actions
    {
        "The player reached the next node in the path to the destination.
If pfCurrentNodeIndex is -1 then pfWalkingToPosition is the destination."
        If(Event Player.pfCurrentNodeIndex == -1);
            "The destination was reached, stop pathfinding."
            Stop Throttle In Direction(Event Player);
            Event Player.pfIsPathfinding = False;
        Else;
            "Update the current pathfind attributes.
Any rules watching these with the matching condition will activate."
            Event Player.pfAttributes = Last Of(First Of(Filtered Array(Global.pfLoadedmap_neighbors[Event Player.pfCurrentNodeIndex], First Of(Current Array Element) == Last Of(Event Player.pfPath))));
            "Go to the next node in the path."
            Event Player.pfCurrentNodeIndex = Last Of(Event Player.pfPath);
            "Pop the current path."
            Modify Player Variable(Event Player, pfPath, Remove From Array By Index, Count Of(Event Player.pfPath) - 1);
            "Set the position that the player is currently walking towards."
            Event Player.pfWalkingToPosition = Event Player.pfCurrentNodeIndex == -1 ? Event Player.pfDestination : Global.pfLoadedmap_nodes[Event Player.pfCurrentNodeIndex];
        End;
        Wait(0.2, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule("Subroutine: Pathfind Player")
{

    event
    {
        Subroutine;
        pathfindPlayer;
    }

    actions
    {
        Global.start = Index Of Array Value(Global.pfLoadedmap_nodes, First Of(Sorted Array(Array Slice(Sorted Array(Global.pfLoadedmap_nodes, Distance Between(Current Array Element, Position Of(Global.player))), 0, 5), !Is In Line Of Sight(Current Array Element + Up * 2, Position Of(Global.player) + Up * 2, Barriers Do Not Block LOS))));
        Global.goal = Index Of Array Value(Global.pfLoadedmap_nodes, First Of(Sorted Array(Array Slice(Sorted Array(Global.pfLoadedmap_nodes, Distance Between(Current Array Element, Global.destination)), 0, 5), !Is In Line Of Sight(Current Array Element + Up * 2, Global.destination + Up * 2, Barriers Do Not Block LOS))));
        Global.open = Array(Global.start);
        Global.cameFrom = Mapped Array(Global.pfLoadedmap_nodes, -1);
        Global.gScore = Mapped Array(Global.pfLoadedmap_nodes, 9999);
        Global.gScore[Global.start] = 0;
        Global.iter = 0;
        While(Count Of(Global.open));
            Global.current = First Of(Sorted Array(Global.open, Global.gScore[Current Array Element] + Distance Between(Global.pfLoadedmap_nodes[Current Array Element], Global.pfLoadedmap_nodes[Global.goal]) * 2));
            "If the goal was found, reconstruct the path."
            If(Global.current == Global.goal);
                Small Message(All Players(All Teams), Custom String("Completed in {0} iterations", Global.iter));
                Global.player.pfPath = Array(-1);
                While(Global.current != -1);
                    Modify Player Variable(Global.player, pfPath, Append To Array, Global.current);
                    Global.current = Global.cameFrom[Global.current];
                End;
                Skip(17);
            End;
            Modify Global Variable(open, Remove From Array By Value, Global.current);
            For Global Variable(neighbor, 0, Count Of(Global.pfLoadedmap_neighbors[Global.current]), 1);
                If(Is True For All(Global.pfLoadedmap_neighbors[Global.current][Global.neighbor][1], Array Contains(Global.attributes, Current Array Element)));
                    Global.neighborI = Global.pfLoadedmap_neighbors[Global.current][Global.neighbor][0];
                    Global.score = Global.gScore[Global.current] + Distance Between(Global.pfLoadedmap_nodes[Global.current], Global.pfLoadedmap_nodes[Global.neighborI]);
                    If(Global.score < Global.gScore[Global.neighborI]);
                        Global.cameFrom[Global.neighborI] = Global.current;
                        Global.gScore[Global.neighborI] = Global.score;
                        If(!Array Contains(Global.open, Global.neighborI));
                            Modify Global Variable(open, Append To Array, Global.neighborI);
                        End;
                    End;
                End;
            End;
            Global.iter += 1;
        End;
        Global.player.pfDestination = Global.destination;
        Global.player.pfIsPathfinding = True;
        Global.player.pfCurrentNodeIndex = Last Of(Global.player.pfPath);
        Global.player.pfWalkingToPosition = Global.pfLoadedmap_nodes[Event Player.pfCurrentNodeIndex];
        Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Global.player.pfWalkingToPosition), 1, To World, Replace Existing Throttle, Direction And Magnitude);
    }
}

