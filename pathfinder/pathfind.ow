variables
{
    global:
        0: pfLoadedMap_nodes
        1: pfLoadedMap_neighbors
    player:
        0: pfDestination
        1: pfPlayerAttributes
        2: pfAttributes
        3: pfSavedTarget
        4: pfIsPathfinding
        5: pfCurrentNodeIndex
        6: pfWalkingToPosition
        7: pfPath
        8: pfStartTime
        9: pfDistanceToNextNode
        10: pfLastNodeStartingPosition
        11: pfNextPosition
        12: pfIsPartialPath
        13: destination
        14: attributes
        15: start
        16: goal
        17: open
        18: cameFrom
        19: gScore
        20: icons
        21: o
        22: icon
        23: current
        24: neighborIcons
        25: neighbor
        26: neighborColor
        27: neighborI
        28: score
        29: icon_0
}

subroutines
{
    0: pathfindPlayer
    1: UpdateNodeMeta
    2: ProgressEventPlayer
}

rule("【PF Core Subroutine】☞ Update node meta")
{

    event
    {
        Subroutine;
        UpdateNodeMeta;
    }

    actions
    {
        "Update the pathfinding start time."
        Event Player.pfStartTime = Total Time Elapsed;
        Event Player.pfDistanceToNextNode = Distance Between(Event Player, Event Player.pfWalkingToPosition);
        Event Player.pfLastNodeStartingPosition = Position Of(Event Player);
        Event Player.pfNextPosition = Count Of(Event Player.pfPath) >= 2 ? Event Player.pfDestination : Global.pfLoadedMap_nodes[Event Player.pfPath[Count Of(Event Player.pfPath) - 2]];
    }
}

rule("【PF Core Subroutine】☞ Pathfind Player")
{

    event
    {
        Subroutine;
        pathfindPlayer;
    }

    actions
    {
        Event Player.start = Index Of Array Value(Global.pfLoadedMap_nodes, First Of(Sorted Array(Array Slice(Sorted Array(Global.pfLoadedMap_nodes, Distance Between(Current Array Element, Position Of(Event Player))), 0, 5), !(Is In Line Of Sight(Current Array Element + Up * 2, Position Of(Event Player) + Up * 2, Barriers Do Not Block LOS) && Absolute Value(Y Component Of(Position Of(Event Player)) - Y Component Of(Current Array Element)) < Distance Between(Position Of(Event Player), Current Array Element) / 2))));
        Event Player.goal = Index Of Array Value(Global.pfLoadedMap_nodes, First Of(Sorted Array(Array Slice(Sorted Array(Global.pfLoadedMap_nodes, Distance Between(Current Array Element, Event Player.destination)), 0, 5), !(Is In Line Of Sight(Current Array Element + Up * 2, Event Player.destination + Up * 2, Barriers Do Not Block LOS) && Absolute Value(Y Component Of(Event Player.destination) - Y Component Of(Current Array Element)) < Distance Between(Event Player.destination, Current Array Element) / 2))));
        Event Player.open = Array(Event Player.start);
        Event Player.cameFrom = Mapped Array(Global.pfLoadedMap_nodes, -1);
        Event Player.gScore = Mapped Array(Global.pfLoadedMap_nodes, 9999);
        Event Player.gScore[Event Player.start] = 0;
        While(Count Of(Event Player.open));
            Event Player.icons = Empty Array;
            For Player Variable(Event Player, o, 0, Count Of(Event Player.open), 1);
                Create In-World Text(All Players(All Teams), Event Player.open[Event Player.o], Global.pfLoadedMap_nodes[Event Player.open[Event Player.o]], 2, Do Not Clip, Visible To, Color(White), Default Visibility);
                Modify Player Variable(Event Player, icons, Append To Array, Last Text ID);
            End;
            Wait Until(!Is Button Held(Host Player, Button(Primary Fire)), 0.2);
            Wait Until(Is Button Held(Host Player, Button(Primary Fire)), 9999);
            For Player Variable(Event Player, icon, 0, Count Of(Event Player.icons), 1);
                Destroy In-World Text(Event Player.icons[Event Player.icon]);
            End;
            Event Player.current = First Of(Sorted Array(Event Player.open, Event Player.gScore[Current Array Element] + Distance Between(Global.pfLoadedMap_nodes[Current Array Element], Global.pfLoadedMap_nodes[Event Player.goal]) * 2));
            "If the goal was found, reconstruct the path."
            If(Event Player.current == Event Player.goal);
                Event Player.pfPath = Array(-1);
                While(Event Player.current != -1);
                    Modify Player Variable(Event Player, pfPath, Append To Array, Event Player.current);
                    Event Player.current = Event Player.cameFrom[Event Player.current];
                    If(Event Player.current != -1);
                        Create Beam Effect(All Players(All Teams), Good Beam, Global.pfLoadedMap_nodes[Last Of(Event Player.pfPath)], Global.pfLoadedMap_nodes[Event Player.current], Color(Rose), Visible To);
                    End;
                End;
                Wait Until(!Is Button Held(Host Player, Button(Primary Fire)), 0.2);
                Wait Until(Is Button Held(Host Player, Button(Primary Fire)), 9999);
                Destroy All Effects;
                Skip(28);
            End;
            Create In-World Text(All Players(All Teams), Event Player.current, Global.pfLoadedMap_nodes[Event Player.current], 2, Do Not Clip, Visible To, Color(Rose), Default Visibility);
            Event Player.neighborIcons = Array(Last Text ID);
            Modify Player Variable(Event Player, open, Remove From Array By Value, Event Player.current);
            "Check each neighbor to the current node."
            For Player Variable(Event Player, neighbor, 0, Count Of(Global.pfLoadedMap_neighbors[Event Player.current]), 1);
                Event Player.neighborColor = Color(Red);
                "Ensure that the path to the neighbor is enabled."
                If(Is True For All(Global.pfLoadedMap_neighbors[Event Player.current][Event Player.neighbor][1], Array Contains(Event Player.attributes, Current Array Element)));
                    Event Player.neighborI = Global.pfLoadedMap_neighbors[Event Player.current][Event Player.neighbor][0];
                    Event Player.score = Event Player.gScore[Event Player.current] + Distance Between(Global.pfLoadedMap_nodes[Event Player.current], Global.pfLoadedMap_nodes[Event Player.neighborI]);
                    Event Player.neighborColor = Color(Blue);
                    If(Event Player.score < Event Player.gScore[Event Player.neighborI]);
                        Event Player.cameFrom[Event Player.neighborI] = Event Player.current;
                        Event Player.gScore[Event Player.neighborI] = Event Player.score;
                        If(!Array Contains(Event Player.open, Event Player.neighborI));
                            Modify Player Variable(Event Player, open, Append To Array, Event Player.neighborI);
                        End;
                        Event Player.neighborColor = Color(Green);
                    End;
                End;
                Create In-World Text(All Players(All Teams), Global.pfLoadedMap_neighbors[Event Player.current][Event Player.neighbor][0], Global.pfLoadedMap_nodes[Global.pfLoadedMap_neighbors[Event Player.current][Event Player.neighbor][0]], 2, Do Not Clip, Visible To, Event Player.neighborColor, Default Visibility);
                Modify Player Variable(Event Player, neighborIcons, Append To Array, Last Text ID);
            End;
            Wait Until(!Is Button Held(Host Player, Button(Primary Fire)), 0.2);
            Wait Until(Is Button Held(Host Player, Button(Primary Fire)), 9999);
            For Player Variable(Event Player, icon_0, 0, Count Of(Event Player.neighborIcons), 1);
                Destroy In-World Text(Event Player.neighborIcons[Event Player.icon_0]);
            End;
        End;
        Event Player.pfDestination = Event Player.destination;
        Event Player.pfIsPathfinding = True;
        Event Player.pfCurrentNodeIndex = Last Of(Event Player.pfPath);
        Event Player.pfWalkingToPosition = Global.pfLoadedMap_nodes[Event Player.pfCurrentNodeIndex];
        Call Subroutine(UpdateNodeMeta);
        Start Throttle In Direction(Event Player, Direction Towards(Position Of(Event Player), Event Player.pfWalkingToPosition), 1, To World, Replace Existing Throttle, Direction And Magnitude);
    }
}

rule("【PF Core】Update & Execute")
{

    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Event Player.pfDestination == True;
        Distance Between(Event Player, Event Player.pfDestination) > 4;
        (!Event Player.pfSavedTarget || Distance Between(Event Player.pfDestination, Event Player.pfSavedTarget) > 5 || Event Player.pfIsPartialPath && Event Player.pfCurrentNodeIndex == -1) == True;
    }

    actions
    {
        Small Message(All Players(All Teams), Custom String("Updated pathfinder for {0}", Event Player));
        Event Player.pfSavedTarget = Event Player.pfDestination;
        Event Player.destination = Event Player.pfDestination;
        Event Player.attributes = Event Player.pfPlayerAttributes;
        Call Subroutine(pathfindPlayer);
        Wait(2, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule("【PF Core Subroutine】☞ Progress event player")
{

    event
    {
        Subroutine;
        ProgressEventPlayer;
    }

    actions
    {
        "Update the current pathfind attributes.
Any rules watching these with the matching condition will activate."
        Event Player.pfAttributes = Last Of(First Of(Filtered Array(Global.pfLoadedMap_neighbors[Event Player.pfCurrentNodeIndex], Current Array Element[0] == Last Of(Event Player.pfPath))));
        "Go to the next node in the path."
        Event Player.pfCurrentNodeIndex = Last Of(Event Player.pfPath);
        "Pop the current path."
        Modify Player Variable(Event Player, pfPath, Remove From Array By Index, Count Of(Event Player.pfPath) - 1);
        "Set the position that the player is currently walking towards."
        Event Player.pfWalkingToPosition = Event Player.pfCurrentNodeIndex == -1 ? Event Player.pfDestination : Global.pfLoadedMap_nodes[Event Player.pfCurrentNodeIndex];
        Call Subroutine(UpdateNodeMeta);
    }
}

disabled rule("【PF Core】Skip node")
{

    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Event Player.pfIsPathfinding == True;
        Event Player.pfCurrentNodeIndex != -1;
        Is In Line Of Sight(Position Of(Event Player) + Vector(0, 0.25, 0), Event Player.pfNextPosition + Vector(0, 0.25, 0), Barriers Do Not Block LOS) == True;
        Absolute Value(Y Component Of(Position Of(Event Player)) - Y Component Of(Event Player.pfNextPosition)) < 1;
    }

    actions
    {
        Small Message(All Players(All Teams), Custom String("Compatible node skip found"));
        Wait(0.1, Ignore Condition);
        Call Subroutine(ProgressEventPlayer);
        Wait(0.1, Ignore Condition);
        Loop If Condition Is True;
    }
}

disabled rule("【PF Core】Stuck")
{

    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Event Player.pfIsPathfinding == True;
        Event Player.pfDistanceToNextNode - 2.75 * (Total Time Elapsed - Event Player.pfStartTime) < 0;
    }

    actions
    {
        Small Message(All Players(All Teams), Custom String("Player {0} got stuck, teleporting them.", Event Player));
        Teleport(Event Player, Event Player.pfWalkingToPosition);
        Wait(3, Ignore Condition);
        Loop If Condition Is True;
    }
}

rule("【PF Core】Node reached")
{

    event
    {
        Ongoing - Each Player;
        All;
        All;
    }

    conditions
    {
        Event Player.pfIsPathfinding == True;
        Distance Between(Event Player, Event Player.pfWalkingToPosition) <= 0.4;
    }

    actions
    {
        "The player reached the next node in the path to the destination."
        If(Event Player.pfCurrentNodeIndex == -1);
            "The destination was reached, stop pathfinding."
            Stop Throttle In Direction(Event Player);
            Event Player.pfIsPathfinding = False;
        Else;
            Call Subroutine(ProgressEventPlayer);
        End;
        Wait(0.2, Ignore Condition);
        Loop If Condition Is True;
    }
}
