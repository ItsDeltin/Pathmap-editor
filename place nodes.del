import 'main.del';

globalvar Any[] controlTexts;
globalvar Number controlTextOrder = 1;
globalvar Number ConnectingFromNodeIndex = -1;
globalvar Boolean attributeMode!;
globalvar Number attribute!;
globalvar Any blueVisual!;
globalvar Any redVisual!;
globalvar Any attributeFloatText!;
globalvar Any cursorMarkerEffect!;
globalvar Any dummyBotHeroIcon!;
globalvar EditorState editorState!;
globalvar Hero placingDummyHero!;

enum EditorState
{
    Node,
    PlaceDummy
}

rule: 'Editor: node mode edit'
if (editorState != EditorState.Node)
{
    DestroyEffect(cursorMarkerEffect);
}

rule: 'Editor: dummy mode exit'
if (editorState != EditorState.PlaceDummy)
{
    DestroyEffect(cursorMarkerEffect);
    DestroyInWorldText(dummyBotHeroIcon);
}

rule: 'Editor: node mode enter'
if (editorState == EditorState.Node)
{
    cursorMarkerEffect = CreateEffect(
        AllPlayers().FilteredArray(p => SelectedNodeID == -1 && !host.cm_isInMenu),
        Effect.Sphere,
        Color.Orange,
        UpdateEveryFrame(watchPoint),
        0.2,
        EffectRev.VisibleToPositionRadiusAndColor);
}

rule: 'Editor: dummy mode enter'
if (editorState == EditorState.PlaceDummy)
{
    cursorMarkerEffect = CreateEffect(
        !host.cm_isInMenu && SelectedPlayer == null && SelectedNodeID == -1 ? AllPlayers() : null,
        Effect.Ring,
        Color.SkyBlue,
        UpdateEveryFrame(watchPoint),
        0.5,
        EffectRev.VisibleToPositionRadiusAndColor);
    
    dummyBotHeroIcon = CreateInWorldText(
        !host.cm_isInMenu && SelectedPlayer == null && SelectedNodeID == -1 ? AllPlayers() : null,
        HeroIconString(placingDummyHero),
        UpdateEveryFrame(watchPoint),
        2,
        Clipping.DoNotClip,
        InworldTextRev.VisibleToAndPosition
    );
}

rule: 'Editor: path mode exit'
if (attributeMode || editorState != EditorState.Node)
{
    DestroyEffect(blueVisual);
    DestroyEffect(redVisual);
}

rule: 'Editor: attribute mode exit'
if (!attributeMode || editorState != EditorState.Node)
{
    DestroyEffect(blueVisual);
    DestroyEffect(redVisual);
    DestroyInWorldText(attributeFloatText);
}

rule: 'Editor: path mode enter'
if (!attributeMode)
if (editorState == EditorState.Node)
{
    MakeVisualBeams(BeamType.TorbjornTurretSightBeam, SelectedSegmentID == -1);
}

rule: 'Editor: attribute mode enter'
if (attributeMode)
if (editorState == EditorState.Node)
{
    MakeVisualBeams(BeamType.SymmetraTurretBeam, true);
    attributeFloatText = CreateInWorldText(
        VisibleTo: ConnectingFromNodeIndex != -1 && ConnectingFromNodeIndex != SelectedNodeIndex ? AllPlayers() : null,
        Header: " \n{0}".Format([attribute]),
        Position: Nodes[ConnectingFromNodeIndex].ShownPosition() - Vector(0, 0.3, 0) + ((SelectedNodeID == -1 ? watchPoint : Nodes[SelectedNodeIndex].ShownPosition()) - Nodes[ConnectingFromNodeIndex].ShownPosition()) * 0.3,
        Scale: 2.5,
        Clipping: Clipping.DoNotClip,
        Reevaluation: InworldTextRev.VisibleToPositionStringAndColor,
        TextColor: SelectedNodeID == -1 ? Color.Red : Color.Blue
    );
}

void MakeVisualBeams(BeamType beamType, in Boolean visualCondition)
{
    DestroyEffect(blueVisual);
    DestroyEffect(redVisual);
    blueVisual = CreateBeamEffect(
        UpdateEveryFrame(visualCondition && ConnectingFromNodeIndex != -1 && SelectedNodeID != -1 ? AllPlayers() : null),
        beamType,
        Nodes[ConnectingFromNodeIndex].ShownPosition(),
        Nodes[SelectedNodeIndex].ShownPosition(),
        Color.Team1,
        EffectRev.VisibleToPositionRadiusAndColor);
    redVisual = CreateBeamEffect(
        UpdateEveryFrame(visualCondition && ConnectingFromNodeIndex != -1 && SelectedNodeID == -1 ? AllPlayers() : null),
        beamType,
        Nodes[ConnectingFromNodeIndex].ShownPosition(),
        UpdateEveryFrame(watchPoint),
        Color.Team2,
        EffectRev.VisibleToPositionRadiusAndColor);
}

rule: 'Editor: Place node'
if (button(Button.PrimaryFire))
if (editorState == EditorState.Node)
if (SelectedNodeID == -1)
if (SelectedPlayer == null)
if (!host.cm_isInMenu)
{
    NodeUniqueID++;
    Number id = NodeUniqueID;
    Vector pos = watchPoint;

    Document({
        Set: () => {
            Nodes += { Node: {Position: pos, UniqueID: id, Neighbors: [[]]}, Visibility: 0, Selected: false, BallEffect: null, RingEffect: null };
            Number chunk! = chunkFromPosition(pos);
            tableAppendValue(host.chunks, chunk, id);
            tryMakeNode(chunk, Nodes.Length - 1);
        },
        Revert: () => {
            Number index! = NodeIndexFromID(id);
            RemoveNodeByIndex(index);
            Number chunk! = chunkFromPosition(pos);
            tableRemoveValue(host.chunks, chunk, id);
            destroyNodeEffect(index);
        }
    });
}

rule: 'Editor: Delete node'
if (button(Button.Ultimate))
if (editorState == EditorState.Node)
if (SelectedNodeID != -1)
if (!host.cm_isInMenu)
{
    Node deleteNode: Nodes[SelectedNodeIndex].Node;

    Document({
        Set: () => {
            SelectedNodeIndex = -1;
            SelectedNodeID = -1;

            // Delete node
            define index = NodeIndexFromID(deleteNode.UniqueID);
            RemoveNodeByIndex(index);
            // Refresh all nodes with indices above the current node.
            for (; index < Nodes.Length; index++) {
                if (Nodes[index].Visibility)
                {
                    DestroyEffect(Nodes[index].BallEffect);
                    DestroyEffect(Nodes[index].RingEffect);
                    Nodes[index].Visibility = 0;
                    MinWait();
                }
            }
        },
        Revert: () => {
            // Add node
            Nodes += { Node: deleteNode, Visibility: 0, Selected: false, BallEffect: null, RingEffect: null };
        }
    });
}

rule: 'Editor: Select node'
if (button(Button.SecondaryFire))
if (editorState == EditorState.Node)
if (SelectedNodeID != -1)
if (!host.cm_isInMenu)
{
    Nodes[SelectedNodeIndex].Selected = !Nodes[SelectedNodeIndex].Selected;
}

rule: 'Editor: Connect node'
if (button(Button.PrimaryFire))
if (editorState == EditorState.Node)
if (SelectedNodeID != -1)
if (!host.cm_isInMenu)
{
    if (ConnectingFromNodeIndex == SelectedNodeIndex)
    {
        ConnectingFromNodeIndex = -1;
        return;
    }
    else if (ConnectingFromNodeIndex != -1)
    {
        // Segment mode
        if (!attributeMode)
        {
            // Delete segment
            if (SelectedSegmentID != -1)
            {
                // Store the segment.
                Vector segment! = Vector(NodeIDFromIndex(ConnectingFromNodeIndex), SelectedSegmentID);
                Document({
                    Set: () => {
                        // Remove respective neighbors.
                        Nodes[NodeIndexFromID(segment.X)].Node.Neighbors -= segment.Y;
                        Nodes[NodeIndexFromID(segment.Y)].Node.Neighbors -= segment.X;
                        destroySegment(segment);
                    },
                    Revert: () => {
                        // Add respective neighbors.
                        Nodes[NodeIndexFromID(segment.X)].Node.Neighbors += segment.Y;
                        Nodes[NodeIndexFromID(segment.Y)].Node.Neighbors += segment.X;
                        showSegment(segment);
                    }
                });
            }
            // Create segment
            else
            {
                // Temp variables for local capture
                Vector segment! = Vector(NodeIDFromIndex(ConnectingFromNodeIndex), NodeIDFromIndex(SelectedNodeIndex));
                Document({
                    Set: () => {
                        Nodes[NodeIndexFromID(segment.X)].Node.Neighbors += segment.Y;
                        Nodes[NodeIndexFromID(segment.Y)].Node.Neighbors += segment.X;
                        showSegment(segment);
                    },
                    Revert: () => {
                        Nodes[NodeIndexFromID(segment.X)].Node.Neighbors -= segment.Y;
                        Nodes[NodeIndexFromID(segment.Y)].Node.Neighbors -= segment.X;
                        destroySegment(segment);
                    }
                });
            }
        }
        // Attribute mode
        else
        {
            Number from! = Nodes[ConnectingFromNodeIndex].Node.UniqueID;
            Number to! = Nodes[SelectedNodeIndex].Node.UniqueID;

            // Find existing attribute.
            Number[] existingAttributeIndex = Attributes.Map((a, i) => i).FilteredArray(
                i => Attributes[i].Value == attribute && Attributes[i].Node1 == from && Attributes[i].Node2 == to
            );

            // Delete attribute
            if (existingAttributeIndex.Length)
            {
                Attribute deleting = Attributes[existingAttributeIndex.First];

                Document({
                    Set: () => {
                        RemoveAttributeByIndex(existingAttributeIndex.First);
                        UpdateAttributeVisibility();
                    },
                    Revert: () => {
                        Attributes += deleting;
                        UpdateAttributeVisibility();
                    }
                });
            }
            // Create attribute
            else
            {
                AttributeUniqueID++;

                // Temp variables for local capture
                Number value! = attribute;
                Number id! = AttributeUniqueID;

                // Create attribute
                Document({
                    Set: () => {
                        Attributes += { Value: value, ID: id, Node1: from, Node2: to };
                        UpdateAttributeVisibility();
                    },
                    Revert: () => {
                        RemoveAttributeByIndex(AttributeIndexFromID(id));
                        UpdateAttributeVisibility();
                    }
                });
            }
        }
    }

    ConnectingFromNodeIndex = SelectedNodeIndex;
}

rule: 'Editor: Cancel link'
if (button(Button.SecondaryFire))
if (editorState == EditorState.Node)
if (SelectedNodeID == -1)
if (ConnectingFromNodeIndex != -1)
if (!host.cm_isInMenu)
{
    ConnectingFromNodeIndex = -1;
}

rule: 'Editor: Place dummy'
if (button(Button.PrimaryFire))
if (editorState == EditorState.PlaceDummy)
if (!host.cm_isInMenu)
if (!host.releasePrimary)
if (SelectedPlayer == null)
if (SelectedNodeID == -1)
{
    CreateDummyBot(placingDummyHero, Team.Team1, -1, watchPoint, facing);
}

rule: 'Editor: Exit dummy mode'
if (button(Button.SecondaryFire))
if (editorState == EditorState.PlaceDummy)
if (!host.cm_isInMenu)
{
    editorState = EditorState.Node;
}

rule: 'Editor: Select dummy'
if (button(Button.PrimaryFire))
if (SelectedPlayer != null)
if (!host.cm_isInMenu)
{
    SelectedPlayer.dummySelected = !SelectedPlayer.dummySelected;
}

rule: 'Editor: tutorial' 1000
{
    CreateHudText(
        HostPlayer(),
        Location: Location.Right,
        Text: ' \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n ',
        SortOrder: 0,
        Reevaluation: HudTextRev.VisibleTo
    );
    AddControlText(
        editorState == EditorState.PlaceDummy ? 'Place dummy' :
            SelectedPlayer != null ? (SelectedPlayer.dummySelected ? 'Unselect player' : 'Select player') :
            SelectedSegmentID != -1 ? (attributeMode ? 'Connect attribute' : 'Delete path') :
            ConnectingFromNodeIndex != -1 && SelectedNodeID != -1 ? (ConnectingFromNodeIndex == SelectedNodeIndex ? (attributeMode ? 'Cancel attribute' : 'Cancel path') : (attributeMode ? 'Connect Attribute' : 'Link path')) :
            ConnectingFromNodeIndex == -1 && SelectedNodeID != -1 ? (attributeMode ? 'Create attribute' : 'Create path') : 'Create node',
        Button.PrimaryFire
    );
    AddControlText(
        editorState == EditorState.Node ? (attributeMode ? 'Cancel attribute' : 'Cancel path') : 'Cancel',
        Button.SecondaryFire,
        (editorState == EditorState.Node && ConnectingFromNodeIndex != -1 && SelectedNodeID == -1) || editorState == EditorState.PlaceDummy
    );
    AddControlText(
        'Destroy node',
        Button.Ultimate,
        SelectedNodeIndex != -1
    );
    AddControlText(
        'Pathfind to cursor',
        Button.Reload,
        AllPlayers().IsTrueForAny(p => p.dummySelected)
    );
    AddControlText(
        'Destroy dummy bot',
        Button.Ultimate,
        AllPlayers().IsTrueForAny(p => p.dummySelected)
    );
    AddControlText(
        'Teleport to cursor',
        Button.Melee,
        AllPlayers().IsTrueForAny(p => p.dummySelected)
    );
    AddControlText(
        AllPlayers().IsTrueForAny(p => p.IsDummy() && p.dummySelected) ? 'Unselect all bots' : 'Select all bots',
        Button.Ability1,
        AllPlayers().IsTrueForAny(p => p.IsDummy())
    );
}

void AddControlText(in String text, in Button button, in Boolean condition = true)
{
    controlTexts += CreateHudText(
        !host.cm_isInMenu && condition ? HostPlayer() : null,
        Location: Location.Right,
        Text: '{0}: {1}{2}{2}{2}{2}'
            .Format([text, InputBindingString(button), '                                                        ']),
        TextColor: CustomColor(255, 255, 255, 162.435),
        SortOrder: controlTextOrder,
        Reevaluation: HudTextRev.VisibleToStringAndColor
    );
    controlTextOrder++;
}

void DestroyControlTexts() 'Destroy control texts'
{
    while (controlTexts.Length)
    {
        DestroyHudText(controlTexts.First);
        controlTexts.ModRemoveByIndex(0);
    }
    controlTextOrder = 1;
}