import 'main.del';

globalvar Any[] controlTexts;
globalvar Number controlTextOrder = 1;
globalvar Number connectingFromNode = -1;

rule: 'Editor: Place node'
if (button(Button.PrimaryFire))
if (SelectedNodeID == -1)
if (!host.cm_isInMenu)
{
    NodeUniqueID++;
    Number id = NodeUniqueID;
    Vector pos = watchPoint;

    Document({
        Set: () => {
            Nodes += { Node: {Position: pos, UniqueID: id}, Visibility: 0, Selected: false, BallEffect: null, RingEffect: null };
            UpdateNodeVisibility(Nodes.Length - 1);
        },
        Revert: () => {
            RemoveNodeByIndex(NodeIndexFromID(id));
        }
    });
}

rule: 'Editor: Select node'
if (button(Button.SecondaryFire))
if (SelectedNodeID != -1)
if (!host.cm_isInMenu)
{
    Nodes[SelectedNodeIndex].Selected = !Nodes[SelectedNodeIndex].Selected;
}

rule: 'Editor: Connect node'
if (button(Button.PrimaryFire))
if (SelectedNodeID != -1)
if (!host.cm_isInMenu)
{
    if (connectingFromNode == SelectedNodeIndex)
    {
        connectingFromNode = -1;
        return;
    }
    else if (connectingFromNode != -1)
    {
        // Create segment
        SegmentUniqueID++;
        Number id! = SegmentUniqueID;
        Number from! = Nodes[connectingFromNode].Node.UniqueID;
        Number to! = Nodes[SelectedNodeIndex].Node.UniqueID;

        Document({
            Set: () => {
                Segments += { ID: id, Node1: from, Node2: to, Effect: null };
                UpdateSegmentVisibility(Segments.Length - 1);
            },
            Revert: () => {
                RemoveSegmentByIndex(SegmentIndexFromID(id));
            }
        });
    }

    connectingFromNode = SelectedNodeIndex;
}

void AddControlText(in String text, in Button button, in Boolean condition = true)
{
    controlTexts += CreateHudText(
        HostPlayer(),
        Location: Location.Left,
        Text: '                                                                                                 {0}: {1}'
            .Format([text, InputBindingString(button)]),
        TextColor: condition ? Color.White : Color.Gray,
        SortOrder: controlTextOrder,
        Reevaluation: HudTextRev.VisibleToStringAndColor
    );
    controlTextOrder++;
}

void DestroyControlTexts() 'Destroy control texts'
{
    while (controlTexts.Length)
    {
        DestroyHudText(controlTexts.First);
        controlTexts.ModRemoveByIndex(0);
    }
    controlTextOrder = 1;
}