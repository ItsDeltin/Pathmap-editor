import 'main.del';
import 'actions.del';

struct Rule
{
    public RuleAction[] Actions;
    public Number ExecutesOnAttribute;
    public Boolean[] EnabledHeroes;
}

struct RuleAction
{
    public String Label;
    public () => void Executor;
    public Vector Export;
}

globalvar persist Rule[] Rules = [];
# The index of the currently visible rule page. To be used with `Rules[rulePage]`.
globalvar Number rulePage!;
globalvar Any rulePageText!;
globalvar Any previousRuleText!;
globalvar Any nextRuleText!;
globalvar Any deleteActionText!;
globalvar Any moveActionsUpText!;
globalvar Any moveActionsDownText!;
globalvar NumberSelector ruleAttributeSelector!;
globalvar Number[] pagerButtons = [];
globalvar Scrollbar actionScrollBar!;
globalvar Scrollbar heroScrollBar!;
globalvar Number waitTime!;
globalvar Any waitTimeText!;
# If this is true, it is assumed that `actionScrollBar` is not null.
globalvar Boolean pagerInitialized!;
# Determines if an action in the list is selected. `actionsSelected[x]` corresponds to `Rules[rulePage].Actions[x]`.
# 
# May not be the same length as `Rules[rulePage].Actions`.
globalvar Boolean[] actionsSelected;

Color deleteActionEnabledColor: Color.Red;
Color deleteActionDisabledColor: CustomColor(252, 0, 0, 50.745000000000005);

Boolean isRulePageVisible(Number ruleIndex): menuState == MenuState.Rules && pagerInitialized && actionScrollBar && ruleIndex == rulePage;

void SetupRuleMenu() 'Setup rule menu'
{
    setMainLabel('main / rule editor');

    buttonCollectionMain += createButton(
        'Add rule',
        primaryAction: MenuAction.CreateRule,
        posY: 0.8,
        scale: 3
    );

    createHelpButton(0, 1, null, [
        MessageLine.Separator('Rule Editor', Color.Rose),
        MessageLine.Text('Rules can be created which allows pathfinding bots to execute actions when they reach a path tagged\n'
            + 'with a certain attribute. You can make bots jump over obstacles, melee fences, or even use hero abilities\n'
            + 'to scale walls and cliffs.\n'),
        MessageLine.Text('The rules created here can be exported into workshop code in the export menu.\n', Color.LimeGreen),
        MessageLine.Separator('Action list', Color.SkyBlue),
        MessageLine.Text('The actions that are executed when the attribute is reached.'),
        MessageLine.Separator('Attribute', Color.Yellow),
        MessageLine.Text('When a bot begins walking on a path with this value, the rule is executed.'),
        MessageLine.Separator('Hero list', Color.Red),
        MessageLine.Text('The list of heroes that this rule will execute for.')
    ]);

    if (Rules.Length)
        initiatePager();
}

// When a new rule is selected, this updates the content.
void updateRuleContent() 'CM: Update rule content'
{
    SetLabel(rulePageText, ' rule ' + (rulePage + 1));
    
    SetInteractability(previousRuleText, rulePage != 0);
    SetColor(previousRuleText, rulePage != 0 ? Color.White : Color.Gray);

    SetInteractability(nextRuleText, rulePage < Rules.Length - 1);
    SetColor(nextRuleText, rulePage < Rules.Length - 1 ? Color.White : Color.Gray);

    RefreshActionList();

    // Update the attribute label.
    if (ruleAttributeSelector != null)
        ruleAttributeSelector.Set(Rules[rulePage].ExecutesOnAttribute);

    updateAllHeroIcons();
}

void updateAllHeroIcons() 'CM: Update all hero icons'
{
    // Update the hero selector
    for (waitlessI = 0; AllHeroes().Length; 1)
        updateHeroIcon(waitlessI);
}

void initiatePager() 'CM: Initiate pager'
{
    if (pagerInitialized) return;
    pagerInitialized = true;

    previousRuleText = createButton(
        '←',
        primaryAction: MenuAction.RulePrevious,
        posY: 0.55,
        posX: -0.35,
        scale: 4
    );
    nextRuleText = createButton(
        '→',
        primaryAction: MenuAction.RuleNext,
        posY: 0.55,
        posX: 0.35,
        scale: 4
    );
    pagerButtons += createButton(
        'add action...',
        primaryAction: MenuAction.AddAction,
        clickWidth: 1.2,
        posY: 0.75,
        posX: -1.75,
        scale: 2
    );
    pagerButtons += createButton(
        ' attribute',
        posY: 0.3,
        scale: 1.75,
        interactable: false
    );
    ruleAttributeSelector = new NumberSelector(Rules[rulePage].ExecutesOnAttribute, 0, 0.1, true, value => Rules[rulePage].ExecutesOnAttribute = value);
    deleteActionText = createButton(
        'delete action',
        primaryAction: MenuAction.DeleteAction,
        posY: -0.6,
        posX: -0.725,
        clickWidth: 1.3,
        scale: 2,
        defaultColor: deleteActionDisabledColor,
        hoverColor: Color.Rose,
        interactable: false
    );
    moveActionsUpText = createButton(
        '↑',
        onClick: left => MoveSelectedActions(true),
        posX: -0.825, posY: -0.8, clickWidth: .2, clickHeight: .2,
    );
    moveActionsDownText = createButton(
        '↓',
        onClick: left => MoveSelectedActions(false),
        posX: -0.625, posY: -0.8, clickWidth: .2, clickHeight: .2,
    );
    rulePageText = createButton(
        ' rule 1',
        posY: 0.55,
        clickWidth: 0.7,
        scale: 3,
        interactable: false
    );

    heroScrollBar = new Scrollbar(
        1.75,
        0.5,
        AllHeroes().Map((hero, i) => '{0} {1}'.Format([HeroIconString(hero), Rules[rulePage].EnabledHeroes[i] ? 'yes' : 'no'])),
        4,
        toggleHero => {
            Rules[rulePage].EnabledHeroes[toggleHero] = !Rules[rulePage].EnabledHeroes[toggleHero];
            updateHeroIcon(toggleHero);
        }
    );
    pagerButtons += createButton(
        'toggle all',
        posX: 1.75,
        posY: 0.7,
        clickWidth: 0.8,
        scale: 1.75,
        primaryAction: MenuAction.ToggleAll
    );

    pagerButtons += [previousRuleText, nextRuleText, deleteActionText, moveActionsUpText, moveActionsDownText, rulePageText];
    buttonCollectionMain += pagerButtons;
    updateRuleContent();
}

void loadActionScrollbar() '(Subroutine) CM: Load action scrollbar'
{
    actionScrollBar = new Scrollbar(
        -1.75,
        0.5,
        Rules[rulePage].Actions.Map(action => action.Label),
        6,
        item => {
            actionsSelected[item] = !actionsSelected[item];
            updateActionSelectColor(item);
        });
}

void updateActionSelectColor(in Number actionIndex)
{
    actionScrollBar.SetButtonColor(actionIndex, actionsSelected[actionIndex] ? Color.Green : Color.White);
}

void updateHeroIcon(in Number index)
{
    // Update button color
    heroScrollBar.SetButtonColor(index, Rules[rulePage].EnabledHeroes[index] ? Color.Green : Color.Red);
    // Update button label
    heroScrollBar.SetButtonLabel(
        index,
        '{0} {1}'.Format([
            HeroIconString(AllHeroes()[index]),
            Rules[rulePage].EnabledHeroes[index] ? 'yes' : 'no'
        ])
    );
}

rule: 'CM: Enable delete action button' 1000
Event.OngoingPlayer
if (menuState == MenuState.Rules)
if (pagerInitialized)
if (actionsSelected.IsTrueForAny(action => action))
{
    SetInteractability(deleteActionText, true);
    SetColor(deleteActionText, deleteActionEnabledColor);
}

rule: 'CM: Disable delete action button' 1000
Event.OngoingPlayer
if (menuState == MenuState.Rules)
if (pagerInitialized)
if (actionsSelected.IsTrueForAll(action => !action))
{
    SetInteractability(deleteActionText, false);
    SetColor(deleteActionText, deleteActionDisabledColor);
}

rule: 'CM: Enable Move Actions Up' 1000
Event.OngoingPlayer
if (menuState == MenuState.Rules)
if (pagerInitialized)
if (actionsSelected.IsTrueForAny(action => action))
if (!actionsSelected[0])
{
    SetInteractability(moveActionsUpText, true);
    SetColor(moveActionsUpText, Color.White);
}

rule: 'CM: Disable Move Actions Up' 1000
Event.OngoingPlayer
if (menuState == MenuState.Rules)
if (pagerInitialized)
if (actionsSelected[0] || actionsSelected.IsTrueForAll(action => !action))
{
    SetInteractability(moveActionsUpText, false);
    SetColor(moveActionsUpText, Color.Gray);
}

rule: 'CM: Enable Move Actions Down' 1000
Event.OngoingPlayer
if (menuState == MenuState.Rules)
if (pagerInitialized)
if (actionsSelected.IsTrueForAny(action => action))
if (!actionsSelected[Rules[rulePage].Actions.Length - 1])
{
    SetInteractability(moveActionsDownText, true);
    SetColor(moveActionsDownText, Color.White);
}

rule: 'CM: Disable Move Actions Down' 1000
Event.OngoingPlayer
if (menuState == MenuState.Rules)
if (pagerInitialized)
if (actionsSelected[Rules[rulePage].Actions.Length - 1] || actionsSelected.IsTrueForAll(action => !action))
{
    SetInteractability(moveActionsDownText, false);
    SetColor(moveActionsDownText, Color.Gray);
}

rule: 'CM: Enter rule menu'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.RuleMenu)
{
    SetMenuState(MenuState.Rules);
}

rule: 'CM: Add action'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.AddAction)
{
    SetMenuState(MenuState.AddAction);
    actionScrollBar = new Scrollbar(0, 0.75, [
        'wait...',
        'jump',
        'start holding jump',
        'stop holding jump',
        'ability 1',
        'ability 2',
        'melee',
        'primary fire',
        'secondary fire',
        'stop walking',
        'walk to destination',
        'look at floor',
        'look at destination'
    ], 8, item => {
        DestroyScrollbar();

        // Wait length
        if (item == 0)
        {
            SetMenuState(MenuState.ChooseWaitLength);
            waitTime = 0.016;
            waitTimeText = createButton('wait time: ' + waitTime + ' seconds', scale: 1.5, defaultColor: Color.Yellow, interactable: false);
            
            buttonCollectionMain += createButton('←', primaryAction: MenuAction.WaitTimeDown, secondaryAction: MenuAction.WaitTimeDownBig, posX: -0.6, scale: 4);
            buttonCollectionMain += createButton('→', primaryAction: MenuAction.WaitTimeUp, secondaryAction: MenuAction.WaitTimeUpBig, posX: 0.6, scale: 4);
            buttonCollectionMain += createButton('Add action', primaryAction: MenuAction.WaitConfirm, posY: -0.15, scale: 2, defaultColor: Color.Green);
            buttonCollectionMain += waitTimeText;
        }
        else
        {            
            DocumentAction(CreateAction(item));
            SetMenuState(MenuState.Rules);
        }
    });
}

rule: 'CM: Delete action'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.DeleteAction)
{
    RuleAction[] deleting! = [];
    Number[] originalIndices! = [];

    for (waitlessI = 0; actionsSelected.Length; 1) 
        if (actionsSelected[waitlessI])
        {
            deleting += [Rules[rulePage].Actions[waitlessI]];
            originalIndices += waitlessI;
        }
    
    actionsSelected = [];
    
    // Capture rulePage
    Number ruleIndex! = rulePage;
    
    Document({
        Set: () => {
            for (Number i! = 0; deleting.Length; 1)
            {
                // Subtract originalIndices[i] by i because the positions shift while the items are removed.
                // This assumes that every element in originalIndicies is less than the next one like [x] < [x + 1] < [x + 2] ect.
                Rules[ruleIndex].Actions.ModRemoveByIndex(originalIndices[i] - i);

                if (isRulePageVisible(ruleIndex))
                    actionScrollBar.Remove(originalIndices[i] - i);
            }
        },
        Revert: () => {
            for (Number i! = 0; deleting.Length; 1)
            {
                Rules[ruleIndex].Actions = insert(Rules[ruleIndex].Actions, originalIndices[i], deleting[i]);

                if (isRulePageVisible(ruleIndex))
                    actionScrollBar.Insert(originalIndices[i], deleting[i].Label);
            }
        }
    });
}

rule: 'CM: Next rule'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.RuleNext)
{
    rulePage++;
    actionsSelected = [];
    updateRuleContent();
}

rule: 'CM: Previous rule'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.RulePrevious)
{
    rulePage--;
    actionsSelected = [];
    updateRuleContent();
}

rule: 'CM: Create rule'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.CreateRule)
{
    rulePage = Rules.Length;

    Document({
        Set: () => {
            Rules.ModAppend([{ Actions: [], ExecutesOnAttribute: 0, EnabledHeroes: AllHeroes().Map(hero => true) }]);
            initiatePager();
            updateRuleContent();
        },
        Revert: () => {
            define removeIndex! = Rules.Length - 1;
            Rules.ModRemoveByIndex(removeIndex);
        }
    });
}

rule: 'CM: Wait time'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.WaitTimeDown || cm_currActionID == MenuAction.WaitTimeUp || cm_currActionID == MenuAction.WaitTimeDownBig || cm_currActionID == MenuAction.WaitTimeUpBig)
{
    if (cm_currActionID == MenuAction.WaitTimeDown)
        waitTime -= 0.02;
    else if (cm_currActionID == MenuAction.WaitTimeUp)
        waitTime += 0.02;
    else if (cm_currActionID == MenuAction.WaitTimeDownBig)
        waitTime -= 0.5;
    else if (cm_currActionID == MenuAction.WaitTimeUpBig)
        waitTime += 0.5;
    
    ModifyVariable(waitTime, Operation.Max, 0.02);
    SetLabel(waitTimeText, 'wait time: ' + waitTime + ' seconds');
}

rule: 'CM: Wait confirm'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.WaitConfirm)
{
    Number wait: waitTime;
    DocumentAction({ Label: 'wait ' + wait, Executor: () => Wait(wait), Export: Vector(0, wait, 0) });
    SetMenuState(MenuState.Rules);
}

rule: 'CM: Toggle all'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.ToggleAll)
{
    Boolean setTo! = Rules[rulePage].EnabledHeroes.IsTrueForAny(hero => !hero);
    Rules[rulePage].EnabledHeroes = AllHeroes().Map(_ => setTo);
    updateAllHeroIcons();
}

rule: 'CM: Exit rule menu'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.Back)
if (menuState == MenuState.Rules || menuState == MenuState.Guide || menuState == MenuState.Export)
{
    SetMenuState(MenuState.Main);
}

rule: 'CM: Exit action menu'
Event.OngoingPlayer
if (cm_currActionID == MenuAction.Back)
if (menuState == MenuState.AddAction)
{
    DestroyScrollbar();
    SetMenuState(MenuState.Rules);
}

void DocumentAction(in RuleAction createdAction)
{
    Number ruleIndex! = rulePage;
    Document({
        Set: () => {
            Rules[ruleIndex].Actions += [createdAction];
            // RefreshActionList();
            if (menuState == MenuState.Rules && actionScrollBar)
                actionScrollBar.Add(createdAction.Label);
        },
        Revert: () => {
            Number i! = Rules[ruleIndex].Actions.Length - 1;

            Rules[ruleIndex].Actions.ModRemoveByIndex(i);
            if (menuState == MenuState.Rules && actionScrollBar)
                actionScrollBar.Remove(i);
        }
    });
}

void RefreshActionList()
{
    if (menuState == MenuState.Rules)
    {
        DestroyScrollbar();
        loadActionScrollbar();
    }
}

void DestroyPager()
{
    actionsSelected = [];
    destroyButtonCollection(pagerButtons);
    pagerInitialized = false;
    
    DestroyScrollbar();
    if (ruleAttributeSelector != null)
    {
        ruleAttributeSelector.Dispose();
        ruleAttributeSelector = null;
    }

    if (heroScrollBar != null)
    {
        heroScrollBar.Dispose();
        heroScrollBar = null;
    }
}

void DestroyScrollbar()
{
    if (actionScrollBar)
    {
        actionScrollBar.Dispose();
        actionScrollBar = null;
    }
}

void MoveSelectedActions(Boolean up!) 'Subroutine: Document action move'
{
    // Bounds reached
    if ((up && actionsSelected.First) || (!up && actionsSelected[Rules[rulePage].Actions.Length - 1]))
        return;

    // Make macros from global variables so that the values are captured.
    define selected: actionsSelected;
    define page: rulePage;

    Document({
        Set: () => {
            DoMove(selected, up, page);
        },
        Revert: () => {
            DoMove(selected, !up, page);
        }
    });
}

void DoMove(Boolean[] selected!, Boolean up!, Number page!) 'Subroutine: Execute action move'
{
    // The actions in the current page are about to be moved, so reset selected actions.
    if (isRulePageVisible(page))
    {
        actionsSelected = [];
    }

    // -1 moves the actions up the list, 1 moves them down.
    Number direction! = up ? -1 : 1;
    // Depending on the direction being moved, we will need to either go from zero to selected.Length
    // or from selected.Length to zero.
    for (Number i! = up ? 0 : selected.Length - 1;
        up ? i < selected.Length : i >= 0;
        i -= direction) {
        if (selected[i]) {
            // Shuffle Actions[i] and Actions[i ± 1].
            define action! = Rules[rulePage].Actions[i];
            Rules[rulePage].Actions.ModRemoveByIndex(i);
            Rules[rulePage].Actions = insert(Rules[rulePage].Actions, i + direction, action);

            if (isRulePageVisible(page))
            {
                actionScrollBar.Remove(i);
                actionScrollBar.Insert(i + direction, action.Label);
                actionsSelected[i + direction] = true;
                updateActionSelectColor(i + direction);
            }
        }
    }
}